{"meta":{"title":"Yongheng","subtitle":"在路上","description":"前进","author":"Yongheng","url":"https://guoyongheng.github.io"},"pages":[{"title":"about","date":"2018-05-12T17:04:42.000Z","updated":"2018-05-15T12:56:20.752Z","comments":false,"path":"about/index.html","permalink":"https://guoyongheng.github.io/about/index.html","excerpt":"","text":"还是要写点东西的啊 山东某弱校辣鸡acmer 拥有着一个无趣的灵魂 最近正要准备考研了 欢迎一起来交流学习啊 邮箱：1547615191@qq.com"},{"title":"categories","date":"2018-05-12T17:14:43.000Z","updated":"2018-05-14T04:14:53.592Z","comments":false,"path":"categories/index.html","permalink":"https://guoyongheng.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-12T17:14:15.000Z","updated":"2018-05-14T04:14:16.921Z","comments":false,"path":"tags/index.html","permalink":"https://guoyongheng.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"洛谷 P2286[HNOI2004]宠物收养场","slug":"洛谷 P2286[HNOI2004]宠物收养场","date":"2018-05-16T12:06:16.000Z","updated":"2018-05-16T12:35:25.989Z","comments":true,"path":"2018/05/16/洛谷 P2286[HNOI2004]宠物收养场/","link":"","permalink":"https://guoyongheng.github.io/2018/05/16/洛谷 P2286[HNOI2004]宠物收养场/","excerpt":"","text":"题目https://www.luogu.org/problemnew/show/P2286 题意splay的基本操作 题解splay模板题可以写两个splay来写，也可以添加一个标记，用一个splay来写。我是添加了一个标记，用一个splay写的。当来了一个收养者的时候，cnt + 1，当来到一个宠物的时候，cnt - 1，cnt &gt; 0 表示收养者比宠物多， cnt &lt; 0 表示宠物比收养者多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using std::abs;struct node&#123; int ch[2]; int ff,cnt,sz,val;&#125;;const int MAXN = 1e5+10;const int MOD = 1e6;const int INF = 1000000000;int root,n,tot;node t[MAXN];void PushUp(int x)&#123; t[x].sz = t[t[x].ch[0]].sz + t[t[x].ch[1]].sz + t[x].cnt;&#125;void Rotate(int x)&#123; int y = t[x].ff; int z = t[y].ff; int k = (t[y].ch[1]==x); t[z].ch[t[z].ch[1]==y]=x; t[x].ff = z; t[y].ch[k] = t[x].ch[k^1]; t[t[x].ch[k^1]].ff = y; t[x].ch[k^1] = y; t[y].ff = x; PushUp(y); PushUp(x);&#125;void Splay(int x, int goal)&#123; while(t[x].ff != goal) &#123; int y = t[x].ff; int z = t[y].ff; if(z != goal) (t[z].ch[0]==y)^(t[y].ch[0]==x)?Rotate(x):Rotate(y); Rotate(x); &#125; if(goal == 0) root = x;&#125;void Find(int x)&#123; int u = root; if(!u) return; while(t[u].ch[x &gt; t[u].val] &amp;&amp; x != t[u].val) u = t[u].ch[x &gt; t[u].val]; Splay(u, 0);&#125;void Insert(int x)&#123; int u = root, ff = 0; while(u &amp;&amp; t[u].val != x) &#123; ff = u; t[u].sz++; u = t[u].ch[x &gt; t[u].val]; &#125; if(u) t[u].cnt++, t[u].sz++; else &#123; u = ++tot; if(ff) t[ff].ch[x &gt; t[ff].val] = u; t[u].ch[0] = t[u].ch[1] = 0; t[tot].ff = ff; t[tot].val = x; t[tot].cnt = 1; t[tot].sz = 1; &#125; Splay(u, 0);&#125;int Next(int x, int f)&#123; Find(x); int u = root; if(t[u].val &gt; x &amp;&amp; f) return u; if(t[u].val &lt; x &amp;&amp; !f) return u; u = t[u].ch[f]; while(t[u].ch[f^1]) u = t[u].ch[f^1]; return u;&#125;int FNext(int x, int f)&#123; Find(x); int u = root; if(t[u].val &gt;= x &amp;&amp; f) return u; if(t[u].val &lt;= x &amp;&amp; !f) return u; u = t[u].ch[f]; while(t[u].ch[f^1]) u = t[u].ch[f^1]; return u;&#125;void Delete(int x)&#123; int last = Next(x, 0); int next = Next(x, 1); Splay(last, 0); Splay(next, last); int del = t[next].ch[0]; if(t[del].cnt &gt; 1) &#123; t[del].cnt--; t[del].sz--; Splay(del, 0); &#125; else &#123; t[next].ch[0] = 0; PushUp(next); &#125;&#125;//a=0 表示宠物//a=1 表示领养者int main()&#123; int a,b,cnt = 0; Insert(-INF); Insert(INF); scanf(\"%d\",&amp;n); int res = 0; while(n--) &#123; scanf(\"%d %d\",&amp;a,&amp;b); if(cnt == 0) Insert(b); if(cnt &gt; 0) &#123; if(a == 1) Insert(b); else &#123; int fv = t[FNext(b, 0)].val; int bv = t[FNext(b, 1)].val; if(abs(fv-b) &lt;= abs(bv - b)) &#123; res += abs(fv - b); Delete(fv); &#125; else &#123; res += abs(bv - b); Delete(bv); &#125; &#125; &#125; if(cnt &lt; 0) &#123; if(a == 0) Insert(b); else &#123; int fv = t[FNext(b, 0)].val; int bv = t[FNext(b, 1)].val; if(abs(fv - b) &lt;= abs(bv - b)) &#123; res += abs(fv - b); Delete(fv); &#125; else &#123; res += abs(bv - b); Delete(bv); &#125; &#125; &#125; cnt += (a ? 1:-1); res %= MOD; &#125; printf(\"%d\\n\",res); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://guoyongheng.github.io/categories/数据结构/"}],"tags":[{"name":"splay","slug":"splay","permalink":"https://guoyongheng.github.io/tags/splay/"}]},{"title":"洛谷 P3391【模板】文艺平衡树（Splay）","slug":"洛谷 P3391【模板】文艺平衡树（Splay）","date":"2018-05-14T15:52:55.000Z","updated":"2018-05-14T15:58:17.963Z","comments":true,"path":"2018/05/14/洛谷 P3391【模板】文艺平衡树（Splay）/","link":"","permalink":"https://guoyongheng.github.io/2018/05/14/洛谷 P3391【模板】文艺平衡树（Splay）/","excerpt":"","text":"题目https://www.luogu.org/problemnew/show/P3391 题意写一种数据结构，实现区间翻转的操作 题解splay打个lazy标记就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123; int ch[2]; int ff,cnt,sz,val,lazy;&#125;;const int MAXN = 1e5+10;int root,n,tot,m;node t[MAXN];void PushUp(int x)&#123; t[x].sz = t[t[x].ch[0]].sz + t[t[x].ch[1]].sz + t[x].cnt;&#125;void PushDown(int x)&#123; if(t[x].lazy) &#123; t[t[x].ch[0]].lazy ^= 1; t[t[x].ch[1]].lazy ^= 1; swap(t[x].ch[0], t[x].ch[1]); t[x].lazy ^= 1; &#125;&#125;void Rotate(int x)&#123; int y = t[x].ff; int z = t[y].ff; int k = (t[y].ch[1]==x); t[z].ch[t[z].ch[1]==y]=x; t[x].ff = z; t[y].ch[k] = t[x].ch[k^1]; t[t[x].ch[k^1]].ff = y; t[x].ch[k^1] = y; t[y].ff = x; PushUp(y); PushUp(x);&#125;void Splay(int x, int goal)&#123; while(t[x].ff != goal) &#123; int y = t[x].ff; int z = t[y].ff; if(z != goal) (t[z].ch[0]==y)^(t[y].ch[0]==x)?Rotate(x):Rotate(y); Rotate(x); &#125; if(goal == 0) root = x;&#125;void Insert(int x)&#123; int u = root, ff = 0; while(u &amp;&amp; t[u].val != x) &#123; ff = u; t[u].sz++; u = t[u].ch[x &gt; t[u].val]; &#125; if(u) t[u].cnt++, t[u].sz++; else &#123; u = ++tot; if(ff) t[ff].ch[x &gt; t[ff].val] = u; t[u].ch[0] = t[u].ch[1] = 0; t[tot].ff = ff; t[tot].val = x; t[tot].sz = t[tot].cnt = 1; t[tot].lazy = 0; &#125; Splay(u, 0);&#125;int KTh(int k)&#123; int u = root; while(true) &#123; PushDown(u); if(t[t[u].ch[0]].sz + 1 &lt; k) &#123; k = k - t[t[u].ch[0]].sz - 1; u = t[u].ch[1]; &#125; else if(t[t[u].ch[0]].sz+1 &gt; k) u = t[u].ch[0]; else return u; &#125;&#125;void solve(int l, int r)&#123; l = KTh(l); r = KTh(r+2); Splay(l, 0); Splay(r, l); t[t[t[root].ch[1]].ch[0]].lazy ^= 1;&#125;void Output(int x)&#123; PushDown(x); if(t[x].ch[0]) Output(t[x].ch[0]); if(t[x].val &gt; 1 &amp;&amp; t[x].val &lt; n+2) printf(\"%d \",t[x].val-1); if(t[x].ch[1]) Output(t[x].ch[1]);&#125;int main()&#123; scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n+2; ++i) Insert(i); int l,r; while(m--) &#123; scanf(\"%d %d\",&amp;l, &amp;r); solve(l, r); &#125; Output(root); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://guoyongheng.github.io/categories/数据结构/"}],"tags":[{"name":"splay","slug":"splay","permalink":"https://guoyongheng.github.io/tags/splay/"}]},{"title":"洛谷 P3369【模板】普通平衡树（Treap/SBT）","slug":"洛谷 P3369【模板】普通平衡树（Treap SBT）","date":"2018-05-13T17:14:04.000Z","updated":"2018-05-14T02:30:17.478Z","comments":true,"path":"2018/05/14/洛谷 P3369【模板】普通平衡树（Treap SBT）/","link":"","permalink":"https://guoyongheng.github.io/2018/05/14/洛谷 P3369【模板】普通平衡树（Treap SBT）/","excerpt":"","text":"题目https://www.luogu.org/problemnew/show/P3369 题意splay的基本操作 题解https://blog.csdn.net/qq_30974369/article/details/77587168 把链接中的模板拿来用就好，先插入INF和-INF作为边界，那模板功能不全，我又添加了MinTh函数和KTh函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;struct node&#123; int ch[2]; int ff,cnt,sz,val;&#125;;const int MAXN = 1e5+10;const int INF = 1e8+10;int root,n,tot;node t[MAXN];void PushUp(int x)&#123; t[x].sz = t[t[x].ch[0]].sz + t[t[x].ch[1]].sz + t[x].cnt;&#125;void Rotate(int x)&#123; int y = t[x].ff; int z = t[y].ff; int k = (t[y].ch[1]==x); t[z].ch[t[z].ch[1]==y]=x; t[x].ff = z; t[y].ch[k] = t[x].ch[k^1]; t[t[x].ch[k^1]].ff = y; t[x].ch[k^1] = y; t[y].ff = x; PushUp(y); PushUp(x);&#125;void Splay(int x, int goal)&#123; while(t[x].ff != goal) &#123; int y = t[x].ff; int z = t[y].ff; if(z != goal) (t[z].ch[0]==y)^(t[y].ch[0]==x)?Rotate(x):Rotate(y); Rotate(x); &#125; if(goal == 0) root = x;&#125;void Find(int x)&#123; int u = root; if(!u) return; while(t[u].ch[x &gt; t[u].val] &amp;&amp; x != t[u].val) u = t[u].ch[x &gt; t[u].val]; Splay(u, 0);&#125;void Insert(int x)&#123; int u = root, ff = 0; while(u &amp;&amp; t[u].val != x) &#123; ff = u; t[u].sz++; u = t[u].ch[x &gt; t[u].val]; &#125; if(u) t[u].cnt++, t[u].sz++; else &#123; u = ++tot; if(ff) t[ff].ch[x &gt; t[ff].val] = u; t[u].ch[0] = t[u].ch[1] = 0; t[tot].ff = ff; t[tot].val = x; t[tot].cnt = 1; t[tot].sz = 1; &#125; Splay(u, 0);&#125;int Next(int x, int f)&#123; Find(x); int u = root; if(t[u].val &gt; x &amp;&amp; f) return u; if(t[u].val &lt; x &amp;&amp; !f) return u; u = t[u].ch[f]; while(t[u].ch[f^1]) u = t[u].ch[f^1]; return u;&#125;void Delete(int x)&#123; int last = Next(x, 0); int next = Next(x, 1); Splay(last, 0); Splay(next, last); int del = t[next].ch[0]; if(t[del].cnt &gt; 1) &#123; t[del].cnt--; t[del].sz--; Splay(del, 0); &#125; else &#123; t[next].ch[0] = 0; PushUp(next); &#125;&#125;//查询x的最小排名void MinTh(int x)&#123; Find(x); printf(\"%d\\n\",t[t[root].ch[0]].sz);&#125;//查询排名为x的数void KTh(int x)&#123; int u = root; while(true) &#123; if(x &gt; t[t[u].ch[0]].sz &amp;&amp; x &lt;= t[t[u].ch[0]].sz+t[u].cnt) &#123; printf(\"%d\\n\",t[u].val); return; &#125; else if(x &gt; t[t[u].ch[0]].sz+t[u].cnt) &#123; x -= t[t[u].ch[0]].sz+t[u].cnt; u = t[u].ch[1]; &#125; else u = t[u].ch[0]; &#125;&#125;int main()&#123; root = tot = 0; int opt,x; scanf(\"%d\",&amp;n); Insert(-INF); Insert(INF); for(int i = 0; i &lt; n; ++i) &#123; scanf(\"%d %d\",&amp;opt,&amp;x); if(opt == 1) Insert(x); else if(opt == 2) Delete(x); else if(opt == 3) MinTh(x); else if(opt == 4) KTh(x+1); else if(opt == 5) printf(\"%d\\n\",t[Next(x, 0)].val); else if(opt == 6) printf(\"%d\\n\",t[Next(x, 1)].val); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://guoyongheng.github.io/categories/数据结构/"}],"tags":[{"name":"splay","slug":"splay","permalink":"https://guoyongheng.github.io/tags/splay/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-12T01:40:43.406Z","updated":"2017-10-28T00:39:58.000Z","comments":true,"path":"2018/05/12/hello-world/","link":"","permalink":"https://guoyongheng.github.io/2018/05/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}