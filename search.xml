<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2018%2F11%2F19%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXN 100int num[MAXN] = &#123;4,9,7,3,2,0,1,8,6,5&#125;;void print(int *a, int n)&#123; for(int i = 0; i &lt; n; ++i) printf("%d ",a[i]); puts("");&#125;void swap(int *a, int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125;//定轴法void quickSortOne(int *a, int l, int r)&#123; if(l &gt; r) return ; int i = l, j = r; int axi = a[l]; while(i != j) &#123; while(i &lt; j &amp;&amp; a[j] &gt;= axi) --j; while(i &lt; j &amp;&amp; a[i] &lt;= axi) ++i; if(i &lt; j) swap(&amp;a[i], &amp;a[j]); &#125; a[l] = a[i]; a[i] = axi; quickSortOne(a, l, i-1); quickSortOne(a, i+1, r);&#125;//挖坑法void quickSortTwo(int *a, int l, int r)&#123; if(l &gt; r) return ; int i = l, j = r; int axi = a[l]; while(i != j) &#123; while(i &lt; j &amp;&amp; a[j] &gt;= axi) --j; a[i] = a[j]; while(i &lt; j &amp;&amp; a[i] &lt; axi) ++i; a[j] = a[i]; &#125; a[i] = axi; quickSortTwo(a, l, i-1); quickSortTwo(a, i+1, r);&#125;//采用了挖坑法实现一个统一的排序void mySort(int *a, int l, int r, int (*comp)(void*, void*))&#123; if(l &gt; r) return; int i = l, j = r; int axi = a[l]; while(i != j) &#123; while(i &lt; j &amp;&amp; !comp(&amp;a[j], &amp;axi)) --j; a[i] = a[j]; while(i &lt; j &amp;&amp; comp(&amp;a[i], &amp;axi)) ++i; a[j] = a[i]; &#125; a[i] = axi; mySort(a, l, i-1, comp); mySort(a, i+1, r, comp);&#125;int cmp(int *a , int *b)&#123; return *a &lt; *b;&#125;int main()&#123; mySort(num, 0, 9, cmp); print(num,10); return 0;&#125;]]></content>
      <categories>
        <category>考研c和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[839.2011.C.十一.2]]></title>
    <url>%2F2018%2F11%2F16%2F839-2011-C-%E5%8D%81%E4%B8%80-2%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define MAXN 100char str[MAXN];int num,ratio;//先把一些特殊情况特判掉char* getV(char *s, int *n1, int *flag)&#123; if(isalpha(*s)) &#123; *n1 = 1,*flag = 0; return s+1; &#125; if((*s == '+' || *s == '-') &amp;&amp; isalpha(*(s+1))) &#123; *n1 = (*s=='+'?1:-1), *flag = 0; return s+2; &#125; char ch; int sgn = 1; *n1 = *flag = 0; while(*s) &#123; ch = *s++; if(ch == '+') sgn *= 1; if(ch == '-') sgn *= -1; if(isdigit(ch)) *n1 = (*n1)*10 + (ch - '0'); if(isalpha(*s) || *s == '+' || *s == '-') break; &#125; (*n1) *= sgn; if(isalpha(*s)) &#123; *flag = 0; return s+1; &#125; *flag = 1; return s;&#125;void process(char * hequ)&#123; int n1 = 0,flag = 0; while(*hequ) &#123; hequ = getV(hequ, &amp;n1, &amp;flag); if(flag) num += n1;//flag=1表示是数字 else ratio += n1;//flag=0表示是变量 &#125;&#125;double calcEquation(char* equation)&#123; int len = strlen(equation); char *p1 = equation; char *p2 = NULL; for(int i = 0; i &lt; len; ++i) &#123; if(equation[i] == '=') &#123; p2 = equation+i+1; equation[i] = '\0'; break; &#125; &#125;// puts(p1);puts(p2); num = ratio = 0; process(p1); num = -num, ratio = -ratio; process(p2); double ret = (-num)/(double)ratio; return ret;&#125;//6a-5+1=2-2a//只考虑所有方程式都是合法的情况int main()&#123; scanf("%s",str); double res = calcEquation(str); printf("%.3f",res); return 0;&#125;]]></content>
      <categories>
        <category>考研c和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[839.2010.C.四.2]]></title>
    <url>%2F2018%2F11%2F16%2F839-2010-C-%E5%9B%9B-2%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXN 100char str[MAXN] = &#123;"12341"&#125;;//直接枚举所有状态void smfn(char *s, int m)&#123; int len = strlen(s); int all = 1&lt;&lt;len; for(int i = 0; i &lt; all; ++i) &#123; if(__builtin_popcount(i) != m) continue; for(int b = 0; b &lt; 20; ++b) if(i&amp;(1&lt;&lt;b)) putchar(s[b]); putchar('\n'); &#125;&#125;//直接暴力搜索所有状态char buf[MAXN];int mark[300];void dfs(char *s, int n, int m, int cnt, int dep)&#123; if(dep &gt; n) return; if(cnt == m) &#123; for(int i = 0; i &lt; cnt; ++i) putchar(buf[i]); putchar('\n'); return ; &#125; buf[cnt] = str[dep]; if(!mark[str[dep]]) &#123; mark[str[dep]] = 1; dfs(s, n, m, cnt+1, dep+1); mark[str[dep]] = 0; &#125; dfs(s, n, m, cnt, dep+1);&#125;int main()&#123;// smfn(str, 3);// puts(""); dfs(str, strlen(str), 3, 0, 0); return 0;&#125;]]></content>
      <categories>
        <category>考研c和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[839.2009.C.四.2]]></title>
    <url>%2F2018%2F11%2F16%2F839-2009-C-%E5%9B%9B-2%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string.h&gt;void print(int x)&#123; if(x == 0) return; print(x/2); putchar(x%2 ? 'T':'F');&#125;int main()&#123; int A = 466;//01 1101 0010 True 1 False 0 int B = 236;//00 1110 1100 int C = 699;//10 1011 1011 int ans = 0; int lim = 1&lt;&lt;10; for(ans = 0; ans &lt; lim; ++ans) &#123; if(__builtin_popcount(ans^A) == 3 &amp;&amp; __builtin_popcount(ans^B) == 3 &amp;&amp; __builtin_popcount(ans^C) == 3) &#123; print(ans); puts(""); &#125; &#125;&#125;]]></content>
      <categories>
        <category>考研c和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[839.2009.C.四.1]]></title>
    <url>%2F2018%2F11%2F16%2F839-2009-C-%E5%9B%9B-1%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#define MAXN 16char buf[MAXN];int main()&#123; FILE* fp = fopen("Microsoft.pub","rb"); if(fp == NULL) &#123; perror("error"); return 0; &#125; int cnt = 0; int offset = 0; while((cnt = fread(buf, sizeof(char), MAXN, fp)) != 0) &#123; printf("%08x\t",offset); for(int i = 0; i &lt; cnt; ++i) printf("%02hhx ",buf[i]); putchar(' '); //在最后一行后边补齐空格 for(int i = 0; i &lt; MAXN-cnt; ++i) printf(" "); for(int i = 0; i &lt; cnt; ++i) &#123; if(isprint(buf[i])) putchar(buf[i]); else putchar('.'); &#125; puts(""); offset += cnt; &#125; return 0;&#125;]]></content>
      <categories>
        <category>考研c和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#define MAXN 50100int num[MAXN];int temp[MAXN];int n;void Merge(int l, int mid, int r)&#123; int rlen = 0; int i = l; int j = mid+1; while(i &lt;= mid &amp;&amp; j &lt;= r) &#123; if(num[i] &lt; num[j]) temp[rlen++] = num[i++]; else temp[rlen++] = num[j++]; &#125; while(i &lt;= mid) temp[rlen++] = num[i++]; while(j &lt;= r) temp[rlen++] = num[j++]; for(int i = 0; i &lt; rlen; ++i) num[l+i] = temp[i];&#125;void MergeSort(int l, int r)&#123; if(l &gt;= r) return; int mid = (l+r) &gt;&gt; 1; MergeSort(l,mid); MergeSort(mid+1,r); Merge(l,mid,r);&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;num[i]); MergeSort(0,n-1); for(int i = 0; i &lt; n; ++i) printf("%d\n",num[i]); return 0;&#125;]]></content>
      <categories>
        <category>考研c和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简化printf]]></title>
    <url>%2F2018%2F11%2F13%2F%E7%AE%80%E5%8C%96printf%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#define SP 1#if SP#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdarg.h&gt;void minprintf(char *fmt, ...)&#123; va_list ap; int ival; double dval; char *p, *sval; va_start(ap, fmt); for(p = fmt; *p; ++p) &#123; if(*p != '%') &#123; putchar(*p); continue; &#125; switch(*++p) &#123; case 'd': ival = va_arg(ap, int); printf("%d",ival); break; case 'f': dval = va_arg(ap, double); printf("%f",dval); break; case 's': sval = va_arg(ap, char*); while(*sval) putchar(*sval++); break; default: putchar(*p); break; &#125; &#125; va_end(ap);&#125;int main()&#123; int a = 10; char* str = "12345"; printf("%f\n",0.5); minprintf("%d\n%s\n",a,str); return 0;&#125;#endif // SP]]></content>
      <categories>
        <category>考研c和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简化scanf]]></title>
    <url>%2F2018%2F11%2F13%2F%E7%AE%80%E5%8C%96scanf%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#define MS 1#if MS#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;stdarg.h&gt;#define LOCALFMT 100void minscanf(char *fmt, ...)&#123; va_list ap; int *ival,i = 0; double *dval; unsigned *uval; char *p, localFmt[LOCALFMT], *sval; va_start(ap, fmt); for(p = fmt; *p; ++p) &#123; if(*p != '%') &#123; localFmt[i++] = *p; continue; &#125; localFmt[i++] = '%'; while(*(p+1) &amp;&amp; !isalpha(*(p+1))) localFmt[i++] = *++p; localFmt[i++] = *(p+1); localFmt[i] = '\0'; switch(*++p) &#123; case 'd': case 'i': ival = va_arg(ap, int*); scanf(localFmt, ival); break; case 'x': case 'X': case 'o': case 'u': uval = va_arg(ap, unsigned*); scanf(localFmt, uval); break; case 'f': dval = va_arg(ap, double*); scanf(localFmt, dval); break; case 's': sval = va_arg(ap, char*); scanf(localFmt, sval); break; default: scanf(localFmt); break; &#125; i = 0; &#125; va_end(ap);&#125;int main()&#123; char str[100]; scanf("%s",str); puts(str); return 0;&#125;#endif // MS]]></content>
      <categories>
        <category>考研c和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构7.14]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%847-14%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define MAXN 100typedef struct edge&#123; int u,v,cost;&#125; edge;int par[MAXN];int rank[MAXN];void init(int n)&#123; for(int i = 0; i &lt; n; ++i) &#123; par[i] = i; rank[i] = 0; &#125;&#125;int find(int x)&#123; if(par[x] == x) return x; else return par[x] = find(par[x]);&#125;void unite(int x, int y)&#123; x = find(x); y = find(y); if(x == y) return; if(rank[x] &lt; rank[y]) par[x] = y; else &#123; par[y] = x; if(rank[x] == rank[y]) rank[x]++; &#125;&#125;int same(int x, int y)&#123; return find(x) == find(y);&#125;int cmp(const void* a, const void* b)&#123; return ((edge*)a)-&gt;cost - ((edge*)b)-&gt;cost;&#125;edge es[MAXN];int V,E;//顶点个数和边的个数int kruskal()&#123; qsort(es, E, sizeof(edge), cmp); init(V); int res = 0; for(int i = 0; i &lt; E; ++i) &#123; edge e = es[i]; if(!same(e.u, e.v)) &#123; unite(e.u, e.v); res += e.cost; &#125; &#125; return res;&#125;int main()&#123; return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第七章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构7.13.2]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%847-13-2%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXINT 9999#define MAXN 100int mat[MAXN][MAXN];int n,u;void prim(int cost[][MAXN], int n, int u)&#123; int sum = 0; int lowcost[MAXN], min; int closest[MAXN]; memset(lowcost, 0, sizeof lowcost); memset(closest, 0, sizeof closest); int i,j,k; for(int i = 1; i &lt;= n; ++i) &#123; cost[i][i] = 0; lowcost[i] = cost[u][i]; closest[i] = u; &#125; for(i = 1; i &lt; n; ++i) &#123; min = MAXINT; for(j = 1; j &lt;= n; ++j) &#123; if(lowcost[j] != 0 &amp;&amp; lowcost[j] &lt; min) &#123; min = lowcost[j]; k = j; &#125; &#125;// printf("%d\n",k); sum += lowcost[k]; lowcost[k] = 0; printf("%3d%3d%5d\n",closest[k],k,cost[closest[k]][k]); for(j = 1; j &lt;= n; ++j) &#123; if(cost[k][j] != 0 &amp;&amp; cost[k][j] &lt; lowcost[j]) &#123; lowcost[j] = cost[k][j]; closest[j] = k; &#125; &#125; &#125; printf("%d\n",sum);&#125;int main()&#123; int n,u; scanf("%d %d",&amp;n,&amp;u); int edge; scanf("%d",&amp;edge); int x,y,v; memset(mat, 0x3f, sizeof(mat)); for(int i = 0; i &lt; edge; ++i) &#123; scanf("%d %d %d",&amp;x,&amp;y,&amp;v); mat[x][y] = mat[y][x] = v; &#125;// for(int i = 1; i &lt;= n; ++i)// &#123;// for(int j = 1; j &lt;= n; ++j)// printf("%d ",mat[i][j]);// puts("");// &#125; prim(mat,n,u);&#125;/*6 1101 2 61 4 51 3 12 3 53 4 52 5 33 5 63 6 44 6 25 6 6*/]]></content>
      <categories>
        <category>蔡子经数据结构第七章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构7.13.1]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%847-13-1%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define MAXN 100typedef struct Edge&#123; int u,v,w;&#125; Edge;Edge edges[MAXN];int fa[MAXN];int getf(int x)&#123; if(fa[x] == x) return x; return fa[x] = getf(fa[x]);&#125;//我在这里没有防止退化void merge(int u, int v)&#123; u = getf(u); v = getf(v); if(u != v) fa[v] = u;&#125;void kruskal(Edge* edge, int n)&#123; int u,v,w; int f1,f2; int sum = 0; for(int i = 0; i &lt; n; ++i) &#123; u = edge[i].u; v = edge[i].v; w = edge[i].w; f1 = getf(u); f2 = getf(v); if(f1 == f2) continue; merge(f1, f2); sum += w; &#125; printf("----%d----\n",sum);&#125;int cmp(const void *a, const void *b)&#123; return ((Edge*)a)-&gt;w - ((Edge*)b)-&gt;w;&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i = 1; i &lt;= n; ++i) fa[i] = i; for(int i = 0; i &lt; n; ++i) scanf("%d %d %d",&amp;edges[i].u,&amp;edges[i].v,&amp;edges[i].w); qsort(edges, n, sizeof(Edge), cmp); for(int i = 0; i &lt; n; ++i) printf("%d\n",edges[i].w); kruskal(edges, n);&#125;/*101 2 61 4 51 3 12 3 53 4 52 5 33 5 63 6 44 6 25 6 6*/]]></content>
      <categories>
        <category>蔡子经数据结构第七章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构6.13]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846-13%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MAXN 100int G[MAXN][MAXN];//表示棋盘//我是实在没想到这个遍历方向的前后竟然对效率影响这么大//int dir[8][2] = &#123;// &#123;1,2&#125;,&#123;2,1&#125;,// &#123;2,-1&#125;,&#123;1,-2&#125;,// &#123;-1,-2&#125;,&#123;-2,-1&#125;,// &#123;-1,2&#125;,&#123;-2,1&#125;// &#125;;int dir[8][2]=&#123; &#123;1,2&#125;,&#123;2,1&#125;, &#123;2,-1&#125;,&#123;1,-2&#125;, &#123;-1,-2&#125;,&#123;-2,-1&#125;, &#123;-2,1&#125;,&#123;-1,2&#125;&#125;;int n = 8, m = 8;//8行8列的棋盘int path[65][3];void print()&#123; for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; printf("%d ",G[i][j]); &#125; puts(""); &#125; puts("");&#125;void dfs(int x, int y, int cnt)&#123; if(cnt == n*m) &#123;// print(); for(int i = 0; i &lt; cnt; ++i) &#123; printf("%d %d %d\n",path[i][0],path[i][1],path[i][2]); &#125; exit(0); &#125; int tx,ty; for(int k = 0; k &lt; 8; ++k) &#123; tx = x + dir[k][0]; ty = y + dir[k][1]; if(tx &lt; 0 || ty &lt; 0 || tx &gt;= n || ty &gt;= m) continue; if(G[tx][ty]) continue; G[tx][ty] = cnt+1; path[cnt][0] = tx; path[cnt][1] = ty; path[cnt][2] = cnt-1; dfs(tx, ty, cnt+1); G[tx][ty] = 0; &#125; return ;&#125;int main()&#123; memset(path, 0, sizeof(path)); memset(G, 0, sizeof(G)); G[0][0] = 1; path[0][0] = 0; path[0][1] = 0; path[0][2] = -1; dfs(0,0,1); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第六章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构6.5]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846-5%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node node;struct node&#123; int val,mark; node *lchild,*rchild;&#125;;#define MAXN 100node* Stack[MAXN];int top;node *root = NULL;void initStack()&#123; top = 0;&#125;void push(node *temp)&#123; if(top == MAXN) &#123; puts("error"); exit(0); &#125; Stack[top++] = temp;&#125;node* pop()&#123; if(top == 0) &#123; puts("error"); exit(0); &#125; return Stack[--top];&#125;node* _top()&#123; if(top == 0) &#123; puts("error"); exit(0); &#125; return Stack[top-1];&#125;int isEmpty()&#123; return top == 0;&#125;void visit(node *rt)&#123; printf("%d\n",rt-&gt;val);&#125;node* createNodeWithVal(int val)&#123; node *rt = (node*)malloc(sizeof(node)); rt-&gt;lchild = rt-&gt;rchild = NULL; rt-&gt;val = val; rt-&gt;mark = 0; return rt;&#125;node* createNode()&#123; node *rt = (node*)malloc(sizeof(node)); rt-&gt;lchild = rt-&gt;rchild = NULL; rt-&gt;val = rt-&gt;mark = 0; return rt;&#125;node* createTree()&#123; node *rt = createNodeWithVal(4); rt-&gt;lchild = createNodeWithVal(2); rt-&gt;rchild = createNodeWithVal(6); rt-&gt;lchild-&gt;lchild = createNodeWithVal(1); rt-&gt;lchild-&gt;rchild = createNodeWithVal(3); rt-&gt;rchild-&gt;lchild = createNodeWithVal(5); rt-&gt;rchild-&gt;rchild = createNodeWithVal(7); rt-&gt;lchild-&gt;lchild-&gt;lchild = createNodeWithVal(10); rt-&gt;lchild-&gt;lchild-&gt;lchild-&gt;rchild = createNode(20); return rt;&#125;int mark = 1;//1表示为平衡树，0表示不是平衡树int CalcHeight(node *rt)&#123; if(rt == NULL) return 0; int lh = CalcHeight(rt-&gt;lchild) + 1; int rh = CalcHeight(rt-&gt;rchild) + 1; if(abs(rh-lh) &gt; 1) mark = 0; return lh &gt; rh ? lh:rh;&#125;int main()&#123; node *root = createTree(); int height = CalcHeight(root); printf("%d\n",mark);&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第六章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构6.4]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846-4%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node node;struct node&#123; int val,mark; node *lchild,*rchild;&#125;;#define MAXN 100node* Stack[MAXN];int top;node *root = NULL;void initStack()&#123; top = 0;&#125;void push(node *temp)&#123; if(top == MAXN) &#123; puts("error"); exit(0); &#125; Stack[top++] = temp;&#125;node* pop()&#123; if(top == 0) &#123; puts("error"); exit(0); &#125; return Stack[--top];&#125;node* _top()&#123; if(top == 0) &#123; puts("error"); exit(0); &#125; return Stack[top-1];&#125;int isEmpty()&#123; return top == 0;&#125;void visit(node *rt)&#123; printf("%d\n",rt-&gt;val);&#125;node* createNodeWithVal(int val)&#123; node *rt = (node*)malloc(sizeof(node)); rt-&gt;lchild = rt-&gt;rchild = NULL; rt-&gt;val = val; rt-&gt;mark = 0; return rt;&#125;node* createNode()&#123; node *rt = (node*)malloc(sizeof(node)); rt-&gt;lchild = rt-&gt;rchild = NULL; rt-&gt;val = rt-&gt;mark = 0; return rt;&#125;node* createTree()&#123; node *rt = createNodeWithVal(4); rt-&gt;lchild = createNodeWithVal(2); rt-&gt;rchild = createNodeWithVal(6); rt-&gt;lchild-&gt;lchild = createNodeWithVal(1); rt-&gt;lchild-&gt;rchild = createNodeWithVal(3); rt-&gt;rchild-&gt;lchild = createNodeWithVal(5); rt-&gt;rchild-&gt;rchild = createNodeWithVal(7); rt-&gt;lchild-&gt;lchild-&gt;lchild = createNodeWithVal(10); return rt;&#125;int CalcHeight(node *rt)&#123; if(rt == NULL) return 0; int lh = CalcHeight(rt-&gt;lchild) + 1; int rh = CalcHeight(rt-&gt;rchild) + 1; return lh &gt; rh ? lh:rh;&#125;int main()&#123; node *root = createTree(); int height = CalcHeight(root); printf("%d\n",height);&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第六章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构6.3]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846-3%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node node;struct node&#123; int val; node *lchild,*rchild;&#125;;#define MAXN 100node* createNodeWithVal(int val)&#123; node *rt = (node*)malloc(sizeof(node)); rt-&gt;lchild = rt-&gt;rchild = NULL; rt-&gt;val = val; return rt;&#125;node* createTree()&#123; node *rt = createNodeWithVal(4); rt-&gt;lchild = createNodeWithVal(2); rt-&gt;rchild = createNodeWithVal(6); rt-&gt;lchild-&gt;lchild = createNodeWithVal(1); rt-&gt;lchild-&gt;rchild = createNodeWithVal(3); rt-&gt;rchild-&gt;lchild = createNodeWithVal(5); rt-&gt;rchild-&gt;rchild = createNodeWithVal(7); return rt;&#125;//判断一棵二叉树是否是查找树//这里假设树中存储的键值全为正整数，则这里用0来当作无穷小,9999当作无穷大int flag = 1;//flag = 1表示是查找树//flag为0表示不是查找树int Judge(node *rt,int mark)&#123; if(rt == NULL) return mark ? 9999 : 0; int lc = Judge(rt-&gt;lchild, 0);//0表示左孩子 int rc = Judge(rt-&gt;rchild, 1);//1表示右孩子 if(rt-&gt;val &lt;= lc || rt-&gt;val &gt;= rc) flag = 0; if(rc == 9999) rc = 0;//忽略掉这个额外添加的最大值，不然就把这个虚无的最大值算进返回值里了 int mm = lc &gt; rc ? lc : rc; return rt-&gt;val &gt; mm ? rt-&gt;val : mm;&#125;int main()&#123; node *root = createTree(); Judge(root,0); printf("%d\n",flag); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第六章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构6.2]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846-2%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node node;struct node&#123; int val,mark; node *lchild,*rchild;&#125;;#define MAXN 100int a[MAXN] = &#123;1,2,3,4,5,6,7&#125;;node* createNode()&#123; node *rt = (node*)malloc(sizeof(node)); rt-&gt;lchild = rt-&gt;rchild = NULL; rt-&gt;val = rt-&gt;mark = 0; return rt;&#125;node *createTree(int l, int r)&#123; if(l &gt; r) return NULL; int mid = (l+r)/2; node *rt = createNode(); rt-&gt;val = a[mid]; rt-&gt;lchild = createTree(l, mid-1); rt-&gt;rchild = createTree(mid+1, r); return rt;&#125;void InOrder(node *rt)&#123; if(rt == NULL) return; InOrder(rt-&gt;lchild); printf("%d ",rt-&gt;val); InOrder(rt-&gt;rchild);&#125;int main()&#123; node* root = createTree(0, 6); InOrder(root); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第六章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构5.11]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-11%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int ltag; char data; int rtag;&#125; node;#define MAXN 8node a[MAXN] =&#123; &#123;0,'A',0&#125;, &#123;1,'B',0&#125;, &#123;0,'D',1&#125;, &#123;1,'F',1&#125;, &#123;0,'C',1&#125;, &#123;0,'E',1&#125;, &#123;1,'G',0&#125;, &#123;1,'H',1&#125;&#125;;int idx = 0;int findPar(int par, char aim)&#123; int cur = idx; idx++; if(a[cur].data == aim) return par; int ret = -1; if(a[cur].ltag == 0) ret = findPar(cur, aim); if(ret != -1) return ret; if(a[cur].rtag == 0) ret = findPar(cur, aim); return ret;&#125;int main()&#123; int res = findPar(-1, 'D'); if(res == -1) puts("not found"); else printf("%c\n",a[res].data); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第五章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构5.10]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-10%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int ltag; char data; int rchild;&#125; node;#define MAXN 8node a[MAXN] =&#123; &#123;0,'A',4&#125;, &#123;1,'B',2&#125;, &#123;0,'D',-1&#125;, &#123;1,'F',-1&#125;, &#123;0,'C',-1&#125;, &#123;0,'E',-1&#125;, &#123;1,'G',7&#125;, &#123;1,'H',-1&#125;&#125;;typedef struct TreeNode&#123; char data; struct TreeNode *lchild, *rchild;&#125; TNode;TNode* createNode()&#123; TNode *ret = (TNode*)malloc(sizeof(TNode)); ret-&gt;lchild = ret-&gt;rchild = NULL; return ret;&#125;//这个题目要求的功能就在这个函数实现的TNode* createTree(int cur)&#123; TNode *ret = createNode(); ret-&gt;data = a[cur].data; if(a[cur].ltag == 0) ret-&gt;lchild = createTree(cur+1); if(a[cur].rchild != -1) ret-&gt;rchild = createTree(a[cur].rchild); return ret;&#125;void MidOrder(TNode *rt)&#123; if(rt == NULL) return; MidOrder(rt-&gt;lchild); putchar(rt-&gt;data); MidOrder(rt-&gt;rchild);&#125;int main()&#123; TNode *root = createTree(0); MidOrder(root); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第五章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构5.9]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-9%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node node;struct node&#123; int val,mark; node *lchild,*rchild;&#125;;#define MAXN 100node* createNodeWithVal(int val)&#123; node *rt = (node*)malloc(sizeof(node)); rt-&gt;lchild = rt-&gt;rchild = NULL; rt-&gt;val = val; rt-&gt;mark = 0; return rt;&#125;/* 4 2 61 3 5 7*/node* createTree()&#123; node *rt = createNodeWithVal(4); rt-&gt;lchild = createNodeWithVal(2); rt-&gt;rchild = createNodeWithVal(6); rt-&gt;lchild-&gt;lchild = createNodeWithVal(1); rt-&gt;lchild-&gt;rchild = createNodeWithVal(3); rt-&gt;rchild-&gt;lchild = createNodeWithVal(5); rt-&gt;rchild-&gt;rchild = createNodeWithVal(7); return rt;&#125;//判断两棵树是否一样int flag = 1;//falg = 1表示俩树一样，否则，俩树不一样void Judge(node *rt1, node *rt2)&#123; if(rt1 == NULL &amp;&amp; rt2 == NULL) return ; //现在就是俩全都不为空，有一个为空的情况 if((rt1 == NULL &amp;&amp; rt2 != NULL) || (rt1 != NULL &amp;&amp; rt2 == NULL))//说明一个为空，一个不为空，即树的形态不一样 &#123; flag = 0; return ; &#125; Judge(rt1-&gt;lchild, rt2-&gt;lchild); Judge(rt1-&gt;rchild, rt2-&gt;rchild);&#125;int main()&#123; node *rt1 = createTree(); node *rt2 = createTree(); rt2-&gt;rchild-&gt;rchild-&gt;rchild = createNodeWithVal(10); Judge(rt1, rt2); printf("%d\n",flag);&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第五章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构5.8]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-8%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//这本书关于完全二叉树的定义和别的书不大一样啊#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node node;struct node&#123; int val,mark; node *lchild,*rchild;&#125;;#define MAXN 100node* createNodeWithVal(int val)&#123; node *rt = (node*)malloc(sizeof(node)); rt-&gt;lchild = rt-&gt;rchild = NULL; rt-&gt;val = val; rt-&gt;mark = 0; return rt;&#125;/* 4 2 61 3 5 7*/node* createTree()&#123; node *rt = createNodeWithVal(4); rt-&gt;lchild = createNodeWithVal(2); rt-&gt;rchild = createNodeWithVal(6); rt-&gt;lchild-&gt;lchild = createNodeWithVal(1); rt-&gt;lchild-&gt;rchild = createNodeWithVal(3); rt-&gt;rchild-&gt;lchild = createNodeWithVal(5); rt-&gt;rchild-&gt;rchild = createNodeWithVal(7); return rt;&#125;int flag = 0;void Judge(node *rt)&#123; if(rt == NULL) return; Judge(rt-&gt;lchild); Judge(rt-&gt;rchild); if((rt-&gt;lchild == NULL &amp;&amp; rt-&gt;rchild != NULL) || (rt-&gt;lchild != NULL &amp;&amp; rt-&gt;rchild == NULL)) &#123; flag = 1; return; &#125;&#125;int main()&#123; node *root = createTree(); Judge(root); printf("%d\n",flag); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第五章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构5.7]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-7%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXN 100typedef struct node node;struct node&#123; int val; node *lchild,*rchild;&#125;;node* createNode()&#123; node *ret = (node*)malloc(sizeof(node)); ret-&gt;lchild = ret-&gt;rchild = NULL; ret-&gt;val = 0; return ret;&#125; // 0 1 2 3 4 5 6int post[MAXN] = &#123;1,3,2,5,7,6,4&#125;;int in[MAXN] = &#123;1,2,3,4,5,6,7&#125;; // 0 1 2 3 4 5 6node* createTree(int last, int l, int r)&#123; if(l &gt; r) return NULL; node *rt = createNode(); int axi = 0; for(int i = l; i &lt;= r; ++i) &#123; if(in[i] == post[last]); &#123; axi = i; break; &#125; &#125; rt-&gt;val = in[axi]; rt-&gt;lchild = createTree(last - (r-axi) - 1, l, axi-1); rt-&gt;rchild = createTree(last - 1, axi+1, r); return rt;&#125;void InOrder(node *rt)&#123; if(rt == NULL) return; InOrder(rt-&gt;lchild); printf("%d ",rt-&gt;val); InOrder(rt-&gt;rchild);&#125;int main()&#123; node* root = createTree(6, 0, 6); InOrder(root); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第五章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构5.6]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-6%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//根据前序和中序构造二叉树#include &lt;stdio.h&gt;#define MAXN 100typedef struct node node;struct node&#123; int val; node *lchild,*rchild;&#125;;node* createNode()&#123; node *ret = (node*)malloc(sizeof(node)); ret-&gt;lchild = ret-&gt;rchild = NULL; ret-&gt;val = 0; return ret;&#125; // 0 1 2 3 4 5 6int pre[MAXN] = &#123;4,2,1,3,6,5,7&#125;;int in[MAXN] = &#123;1,2,3,4,5,6,7&#125;; // 0 1 2 3 4 5 6node* createTree(int fst, int l, int r)&#123; if(l &gt; r) return NULL; node* rt = createNode(); int axi = 0; for(int i = l; i &lt;= r; ++i) &#123; if(in[i] == pre[fst]) &#123; axi = i; break; &#125; &#125; rt-&gt;val = pre[fst]; rt-&gt;lchild = createTree(fst+1, l, axi-1); rt-&gt;rchild = createTree(fst+axi-l+1, axi+1, r); return rt;&#125;void InOrder(node *rt)&#123; if(rt == NULL) return; InOrder(rt-&gt;lchild); printf("%d ",rt-&gt;val); InOrder(rt-&gt;rchild);&#125;int main()&#123; node *root = createTree(0, 0, 6); InOrder(root); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第五章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构5.5]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-5%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//有些东西参考了王道#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node node;struct node&#123; int val,mark; node *lchild,*rchild;&#125;;#define MAXN 100node* Stack[MAXN];int top;node *root = NULL;//这里不考虑栈满的情况void InitStack()&#123;top = 0;&#125;//初始化栈void Push(node *temp)&#123;Stack[top++] = temp;&#125;//入栈node* Pop()&#123;return Stack[--top];&#125;//返回栈顶元素，同时出栈node* Top()&#123;return Stack[top-1];&#125;//返回栈顶元素int IsEmpty()&#123;return top == 0;&#125;//判断是否为空void visit(node *rt)&#123;printf("%d ",rt-&gt;val);&#125;node* createNodeWithVal(int val)&#123; node *rt = (node*)malloc(sizeof(node)); rt-&gt;lchild = rt-&gt;rchild = NULL; rt-&gt;val = val; rt-&gt;mark = 0; return rt;&#125;/* 4 2 61 3 5 7 4 21 3 5 6*/node* createTree()&#123; node *rt = createNodeWithVal(4); rt-&gt;lchild = createNodeWithVal(2);// rt-&gt;rchild = createNodeWithVal(6); rt-&gt;lchild-&gt;lchild = createNodeWithVal(1); rt-&gt;lchild-&gt;rchild = createNodeWithVal(3); rt-&gt;lchild-&gt;lchild-&gt;rchild = createNodeWithVal(5); rt-&gt;lchild-&gt;lchild-&gt;rchild-&gt;rchild = createNodeWithVal(6);// rt-&gt;rchild-&gt;lchild = createNodeWithVal(5);// rt-&gt;rchild-&gt;rchild = createNodeWithVal(7); return rt;&#125;//二叉树的前序遍历就是原来树的前序遍历void PreOrder(node *rt)&#123; if(rt == NULL) return; printf("%d ",rt-&gt;val); PreOrder(rt-&gt;lchild); PreOrder(rt-&gt;rchild);&#125;//二叉树的中序遍历就是原来树的后续遍历void InOrder(node *rt)&#123; if(rt == NULL) return; InOrder(rt-&gt;lchild); printf("%d ",rt-&gt;val); InOrder(rt-&gt;rchild);&#125;//树转换为二叉树后，用的是兄弟孩子表示法//左孩子为真的孩子，右孩子为兄弟//所以如果对应二叉树中没有子节点或者没有左孩子节点//就是原来树中的叶子节点//综上，只要对应二叉树左孩子为空，就是叶子节点void PrintLeaf(node *rt)&#123; if(rt == NULL) return; if(rt-&gt;lchild == NULL) printf("%d ",rt-&gt;val); PrintLeaf(rt-&gt;lchild); PrintLeaf(rt-&gt;rchild);&#125;//flag=0表示为父节点的左孩子//flag=1表示为父节点的右孩子//不管了啊，对每个节点暴力找他的右孩子的长度即可int CalcDegree(node *rt)&#123; if(rt == NULL) return 0; node *temp = rt; int ret = 0; while(temp) &#123; temp = temp-&gt;rchild; ret++; &#125; int h1 = CalcDegree(rt-&gt;lchild); int h2 = CalcDegree(rt-&gt;rchild); int h = h1 &gt; h2 ? h1: h2; return ret &gt; h ? ret : h;&#125;int main()&#123; node *root = createTree(); PreOrder(root); puts(""); InOrder(root); puts(""); PrintLeaf(root); puts(""); int h = CalcDegree(root); printf("%d\n",h); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第五章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构5.4]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-4%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node node;struct node&#123; int val,mark; node *lchild,*rchild;&#125;;#define MAXN 100node* Stack[MAXN];int top;node *root = NULL;//这里不考虑栈满的情况void InitStack()&#123;top = 0;&#125;//初始化栈void Push(node *temp)&#123;Stack[top++] = temp;&#125;//入栈node* Pop()&#123;return Stack[--top];&#125;//返回栈顶元素，同时出栈node* Top()&#123;return Stack[top-1];&#125;//返回栈顶元素int IsEmpty()&#123;return top == 0;&#125;//判断是否为空void visit(node *rt)&#123;printf("%d ",rt-&gt;val);&#125;node* createNodeWithVal(int val)&#123; node *rt = (node*)malloc(sizeof(node)); rt-&gt;lchild = rt-&gt;rchild = NULL; rt-&gt;val = val; rt-&gt;mark = 0; return rt;&#125;/* 4 2 61 3 5 7*/node* createTree()&#123; node *rt = createNodeWithVal(4); rt-&gt;lchild = createNodeWithVal(2); rt-&gt;rchild = createNodeWithVal(6); rt-&gt;lchild-&gt;lchild = createNodeWithVal(1); rt-&gt;lchild-&gt;rchild = createNodeWithVal(3); rt-&gt;rchild-&gt;lchild = createNodeWithVal(5); rt-&gt;rchild-&gt;rchild = createNodeWithVal(7); return rt;&#125;void PostOrder(node *rt)&#123; InitStack(); node *p = rt; node *r = NULL; while(p || !IsEmpty()) &#123; if(p != NULL) &#123; Push(p); p = p-&gt;lchild; &#125; else &#123; p = Top(); if(p-&gt;rchild != NULL &amp;&amp; p-&gt;rchild != r) &#123; p = p-&gt;rchild; Push(p); p = p-&gt;lchild; &#125; else &#123; p = Pop(); visit(p); r = p; p = NULL; &#125; &#125; &#125;&#125;int main()&#123; node *root = createTree(); PostOrder(root); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第五章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构5.3]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-3%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node node;struct node&#123; int val,mark; node *lchild,*rchild;&#125;;#define MAXN 100node* Stack[MAXN];int top;node *root = NULL;//这里不考虑栈满的情况void InitStack()&#123;top = 0;&#125;//初始化栈void Push(node *temp)&#123;Stack[top++] = temp;&#125;//入栈node* Pop()&#123;return Stack[--top];&#125;//返回栈顶元素，同时出栈node* Top()&#123;return Stack[top-1];&#125;//返回栈顶元素int isEmpty()&#123;return top == 0;&#125;//判断是否为空void visit(node *rt)&#123;printf("%d ",rt-&gt;val);&#125;node* createNodeWithVal(int val)&#123; node *rt = (node*)malloc(sizeof(node)); rt-&gt;lchild = rt-&gt;rchild = NULL; rt-&gt;val = val; rt-&gt;mark = 0; return rt;&#125;node* createNode()&#123; node *rt = (node*)malloc(sizeof(node)); rt-&gt;lchild = rt-&gt;rchild = NULL; rt-&gt;val = rt-&gt;mark = 0; return rt;&#125;/* 4 2 61 3 5 7*/node* createTree()&#123; node *rt = createNodeWithVal(4); rt-&gt;lchild = createNodeWithVal(2); rt-&gt;rchild = createNodeWithVal(6); rt-&gt;lchild-&gt;lchild = createNodeWithVal(1); rt-&gt;lchild-&gt;rchild = createNodeWithVal(3); rt-&gt;rchild-&gt;lchild = createNodeWithVal(5); rt-&gt;rchild-&gt;rchild = createNodeWithVal(7); return rt;&#125;void inOrder(node *rt)&#123; if(rt == NULL) return; inOrder(rt-&gt;lchild); visit(rt); inOrder(rt-&gt;rchild);&#125;void ChangeChild(node *rt)&#123; if(rt == NULL) return; ChangeChild(rt-&gt;lchild); ChangeChild(rt-&gt;rchild); node *temp = rt-&gt;lchild; rt-&gt;lchild = rt-&gt;rchild; rt-&gt;rchild = temp;&#125;int main()&#123; node *root = createTree(); inOrder(root); puts(""); ChangeChild(root); inOrder(root); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第五章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构4.6]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-6%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#if gyh4_6#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;struct node&#123; int row,col,val; struct node *right,*down;&#125;;typedef struct node NODE;NODE *a,*b,*c;NODE* createNullMat(int m, int n)&#123; NODE *p,*h,*q; int k; h = (NODE*)malloc(sizeof(NODE)); h-&gt;row = m; h-&gt;col = n; h-&gt;val = 0; p = h-&gt;right = h-&gt;down = h; for(k = 0; k &lt; m; ++k) &#123; q = (NODE*)malloc(sizeof(NODE)); q-&gt;col = 1000; q-&gt;right = q; q-&gt;down = p-&gt;down; p-&gt;down = q; p = q; &#125; p = h; for(k = 0; i &lt; n; ++k) &#123; q = (NODE*)malloc(sizeof(NODE)); q-&gt;row = 1000; q-&gt;down = q; q-&gt;right = p-&gt;right; p-&gt;right = q; p = q; &#125; return h;&#125;NODE* searchRowLast(NODE *a, int i)&#123; NODE *p, *h; int k; p = a; for(k = 0; k &lt;= i; ++k) p = p-&gt;down; h = p; while(p-&gt;right != h) p = p-&gt;right; return p;&#125;NODE* searchColLast(NODE *a, int j)&#123; NODe *p, *h; int k; p = a; for(k = 0; k &lt;= j; ++k) p = p-&gt;right; h = p; while(p-&gt;down != h) p = p-&gt;down; return p;&#125;void insertNODE(NODE *a, int row, int col, int value)&#123; NODE *p, *q, *r; p = searchRowLast(a, row); q = searchColLast(a, col); r = (NODe*)malloc(sizeof(NODE)); r-&gt;row = row; r-&gt;col = col; r-&gt;val = value; r-&gt;right = p-&gt;right; p-&gt;right = r; r-&gt;down = p-&gt;down; p-&gt;down = r; a-&gt;val++;&#125;NODE* createMat()&#123; int m,n,t,i,j,k,v; NODE *h, *p, *q, *r; puts("input row and col and the number of value"); scanf("%d %d %d",&amp;m,&amp;n,&amp;t); puts("input three tuples"); h = createNullMat(m,n); h-&gt;row = m; h-&gt;col = n; for(k = 1; k &lt;= t; ++k) &#123; scanf("%d %d %d",&amp;i,&amp;j,&amp;v); insertNODE(i, j, v); &#125; return h;&#125;//没毛病，转置矩阵就靠这个函数了NODE* transpositionMat(NODE *a)&#123; NODE *TranMat = createNullMat(a-&gt;col, a-&gt;row); TranMat-&gt;row = a-&gt;col; TranMat-&gt;col = a-&gt;row; TranMat-&gt;val = a-&gt;val; NODE *h, *p; p = a-&gt;down; while(p != a)//一行行的往下扫描 &#123; h = p; h = h-&gt;right; while(h != p) &#123; insertNODE(TranMat, h-&gt;col, h-&gt;row, h-&gt;val); h = h-&gt;right; &#125; p = p-&gt;down; &#125; return TranMat;&#125;int main()&#123; return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第四章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构4.5]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-5%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;stdio.h&gt;#define MAXN 100/*12 15 0 00 0 0 036 46 0 520 0 0 00 72 0 68*/int a[MAXN][3] =&#123; 5,4,7,//行 列 元素个数 0,0,12, 0,1,15, 2,0,36, 2,1,46, 2,3,52, 4,1,72, 4,3,68&#125;;/*12 0 15 00 0 0 036 46 0 520 0 0 00 72 0 68*/int b[MAXN][3] =&#123; 5,4,7,//行 列 元素个数 0,0,12, 0,2,15, 2,0,36, 2,1,46, 2,3,52, 4,1,72, 4,3,68&#125;;int c[MAXN][3];int matrix[MAXN][MAXN];//把矩阵恢复后存储在这里，用于输出结果，便于直观观察void matrixAdd(int a[][3], int b[][3], int c[][3])&#123; int al = a[0][2]; int bl = b[0][2]; c[0][0] = a[0][0]; c[0][1] = a[0][1]; int i = 1, j = 1; int top = 0; while(i &lt;= al &amp;&amp; j &lt;= bl) &#123; if(a[i][0] == b[j][0] &amp;&amp; a[i][1] == b[j][1]) &#123; c[++top][0] = a[i][0]; c[top][1] = a[i][1]; c[top][2] = a[i][2] + b[j][2]; ++i,++j; &#125; else if(a[i][0] &lt; b[j][0] || (a[i][0] == b[j][0] &amp;&amp; a[i][1] &lt; b[j][1])) &#123; c[++top][0] = a[i][0]; c[top][1] = a[i][1]; c[top][2] = a[i][2]; ++i; &#125; else &#123; c[++top][0] = b[j][0]; c[top][1] = b[j][1]; c[top][2] = b[j][2]; ++j; &#125; &#125; while(i &lt;= al) &#123; c[++top][0] = a[i][0]; c[top][1] = a[i][1]; c[top][2] = a[i][2]; &#125; while(j &lt;= bl) &#123; c[++top][0] = b[j][0]; c[top][1] = b[j][1]; c[top][2] = b[j][2]; &#125; c[0][2] = top;&#125;int main()&#123; matrixAdd(a,b,c); for(int i = 1; i &lt;= c[0][2]; ++i) matrix[c[i][0]][c[i][1]] = c[i][2]; for(int i = 0; i &lt; c[0][0]; ++i) &#123; for(int j = 0; j &lt; c[0][1]; ++j) &#123; printf("%d ",matrix[i][j]); &#125; puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第四章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构3.7]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-7%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#define MAXN 100int a[MAXN] = &#123;5,5,6,9,5,2,3,6,5,4&#125;;int stk[MAXN];int top = 0;void InitStack()&#123; top = 0;&#125;void Push(int x)&#123; stk[top++] = x;&#125;int Top()&#123; return stk[top-1];&#125;void Pop()&#123; --top;&#125;int IsEmpty()&#123; return top==0;&#125;int partition(int *a, int l, int r)&#123; if(a == NULL || l &lt; 0 || r &lt;= 0 &amp;&amp; l &gt; r) return -1; int i = l, j = r; int axi = a[i]; while(i != j) &#123; if(i &lt; j &amp;&amp; a[j] &gt;= axi) --j; a[i] = a[j]; if(i &lt; j &amp;&amp; a[i] &lt;= axi) ++i; a[j] = a[i]; &#125; a[i] = axi; return i;&#125;void quickSort(int *a, int l, int r)&#123; if(a == NULL || l &lt; 0 || r &lt;= 0 || l &gt; r) return ; InitStack(); int i = l, j = r,k; Push(j); Push(i); while(!IsEmpty()) &#123; i = Top(); Pop(); j = Top(); Pop(); if(i &lt; j) &#123; k = partition(a, i, j); if(k &gt; i) &#123; Push(k-1); Push(i); &#125; if(k &lt; j) &#123; Push(j); Push(k+1); &#125; &#125; &#125;&#125;int main()&#123; int n = 10; quickSort(a, 0, n-1); for(int i = 0; i &lt; n; ++i) printf("%d\n",a[i]); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第三章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构3.5]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-5%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define MAXN 100typedef struct node&#123; int val; struct node* next;&#125; node;node *createNode()&#123; node *ret = (node*)malloc(sizeof(node)); ret-&gt;val = 0; ret-&gt;next = NULL; return ret;&#125;node *createList(int n)&#123; srand(time(0)); node *head = createNode(); for(int i = 0; i &lt; n; ++i) &#123; node *p = createNode(); p-&gt;val = rand()%100; p-&gt;next = head-&gt;next; head-&gt;next = p; &#125; return head;&#125;node* mergeSort(node *p)&#123; if(p == NULL) return p;//如果是个空指针，直接返回 if(p-&gt;next == NULL) return p;//如果只有一个节点，直接返回 node *fst = p; node *sed = p-&gt;next; while(sed-&gt;next)//快慢指针来寻找链表的中间位置 &#123; fst = fst-&gt;next; sed = sed-&gt;next; if(sed-&gt;next == NULL) break; sed = sed-&gt;next;// if(sed-&gt;next == NULL) break; &#125; sed = fst-&gt;next; fst-&gt;next = NULL; fst = p; fst = mergeSort(fst); sed = mergeSort(sed); p = NULL; node *ret = NULL; while(fst &amp;&amp; sed) &#123; if(fst-&gt;val &lt; sed-&gt;val) &#123; if(p == NULL) ret = p = fst; else &#123; p-&gt;next = fst; p = p-&gt;next; &#125; fst = fst-&gt;next; &#125; else &#123; if(p == NULL) ret = p = sed; else &#123; p-&gt;next = sed; p = p-&gt;next; &#125; sed = sed-&gt;next; &#125; &#125; while(fst) &#123; p-&gt;next = fst; fst = fst-&gt;next; &#125; while(sed) &#123; p-&gt;next = sed; sed = sed-&gt;next; &#125; return ret;&#125;int main()&#123; int n = 10; node *head = createList(n); node *p = head-&gt;next; while(p) &#123; printf("%d\n",p-&gt;val); p = p-&gt;next; &#125; p = head-&gt;next; free(head); head = mergeSort(p);//返回一个没有头结点的指针 puts("----------------------------"); while(head) &#123; printf("%d\n",head-&gt;val); head = head-&gt;next; &#125; return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第三章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构3.4]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-4%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#define MAXN 100int a[MAXN] = &#123;1,4,7,8,5,2,3,6,9,0&#125;;int n;void swap(int *x, int *y)&#123; int t = *x; *x = *y; *y = t;&#125;int main()&#123; n = 10; int num = n; while(num &gt; 0) &#123; for(int i = 0; i &lt; num-1; ++i) if(a[i] &gt; a[i+1]) swap(&amp;a[i], &amp;a[i+1]); for(int i = num-1; i &gt; 0; --i) if(a[i] &lt; a[i-1]) swap(&amp;a[i], &amp;a[i-1]); --num; &#125; for(int i = 0; i &lt; n; ++i) printf("%d\n",a[i]); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第三章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构3.3]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-3%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct node&#123; int val; struct node* next;&#125; node;node* createNode()&#123; node *ret = (node*)malloc(sizeof(node)); ret-&gt;val = 0; ret-&gt;next = NULL; return ret;&#125;int main()&#123; srand(time(0)); node *head = createNode(); for(int i = 0; i &lt; 5; ++i) &#123; node *p = createNode(); p-&gt;val = rand()%100; p-&gt;next = head-&gt;next; head-&gt;next = p; &#125; node *p = head-&gt;next; while(p) &#123; printf("%d,",p-&gt;val); p = p-&gt;next; &#125; puts(""); p = head; node *pre = head; for(; pre-&gt;next;) &#123; node *first = pre-&gt;next; node *mark = first; while(first) &#123; if(first-&gt;val &lt; mark-&gt;val) mark = first; first = first-&gt;next; &#125; pre = pre-&gt;next; int temp = mark-&gt;val; mark-&gt;val = pre-&gt;val; pre-&gt;val = temp; &#125; p = head-&gt;next; while(p) &#123; printf("%d,",p-&gt;val); p = p-&gt;next; &#125; return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第三章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构3.2]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-2%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#define MAXN 100int a[MAXN];int top = 0;typedef struct node&#123; int val; struct node* next;&#125; node;node* createNode()&#123; node* ret = (node*)malloc(sizeof(node)); ret-&gt;next = NULL; ret-&gt;val = -1; return ret;&#125;void Insert(node* pre, node* p, int x)&#123; while(p) &#123; if(x &lt; p-&gt;val) break; pre = pre-&gt;next; p = p-&gt;next; &#125; node *in = createNode(); in-&gt;val = x; in-&gt;next = p; pre-&gt;next = in;&#125;int cmp(const void* a, const void* b)&#123; return *(int*)a - *(int*)b;&#125;int main()&#123; srand(time(NULL)); node* head = createNode(); for(int i = 0; i &lt; 10; ++i) &#123; a[top++] = rand()%100; printf("%d ",a[top-1]); &#125; puts(""); for(int i = 0; i &lt; top; ++i) Insert(head, head-&gt;next, a[i]); node *p = head-&gt;next; while(p) &#123; printf("%d ",p-&gt;val); p = p-&gt;next; &#125; puts(""); qsort(a,top,sizeof(int),cmp); for(int i = 0; i &lt; top; ++i) printf("%d ",a[i]); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第三章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构3.1]]></title>
    <url>%2F2018%2F11%2F12%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-1%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#define MAXN 100int num[MAXN];int n;//a是数组名 n是数组长度 x是要查找的值int binarySearch(int *a, int n, int x)&#123; int l = 0; int r = n-1; if(l &gt; r) return 0; while(l &lt;= r) &#123; int mid = (l+r)&gt;&gt;1; if(x &lt;= a[mid]) r = mid-1; else l = mid+1; &#125; return l;&#125;int main()&#123; int ins; scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d",&amp;ins); int x = binarySearch(num, i, ins); for(int j = i+1; j &gt; x; --j) num[j] = num[j-1]; num[x] = ins; for(int j = 0; j &lt;= i; ++j) printf("%d ",num[j]); puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第三章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构2.4]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-4%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXN 100char str[MAXN];int flink[MAXN];void faillink(char *p, int *flink, int m)&#123; flink[0] = -1; int j = 1, k; while(j &lt; m) &#123; k = flink[j-1]; while(k != -1 &amp;&amp; p[k] != p[j-1]) k = flink[k]; flink[j] = k+1; j++; &#125;&#125;int main()&#123; scanf("%s",str); int len = strlen(str); faillink(str, flink, len); for(int i = 0; i &lt; len; ++i) printf("%d ",flink[i]); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第二章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构2.1]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-1%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define max(a,b) (a&gt;b?a:b)#define MAXN 100char str1[MAXN];char str2[MAXN];int dp[MAXN][MAXN];int main()&#123; memset(dp, 0, sizeof(dp));//其实全局变量默认初始化为0 scanf("%s %s",str1, str2); int len1 = strlen(str1); int len2 = strlen(str2); int res = 0; for(int i = 0; i &lt; len1; ++i) &#123; for(int j = 0; j &lt; len2; ++j) &#123; if(str1[i] == str2[j]) dp[i+1][j+1] = dp[i][j] + 1; res = max(res, dp[i+1][j+1]); &#125; &#125; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第二章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.19]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-19%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int val; struct node* next;&#125; node;node* createNode()&#123; node *ret = (node*)malloc(sizeof(node)); ret-&gt;val = 0; ret-&gt;next = NULL; return ret;&#125;//void print(node *head)&#123; node *p = head-&gt;next; while(p != head) &#123; printf("%d ",p-&gt;val); p = p-&gt;next; &#125; puts(""); return ;&#125;node *modify(node *p)&#123; node *head = createNode(); head-&gt;next = p; node *temp = head; int cnt = 0; while(temp-&gt;next) &#123; ++cnt; temp = temp-&gt;next; &#125; temp-&gt;next = head; head-&gt;val = cnt; return head;&#125;int main()&#123; node *p = NULL, *rec = NULL; for(int i = 0; i &lt; 10; ++i) &#123; if(p == NULL) &#123; p = createNode(); p-&gt;val = i+1; rec = p; &#125; else &#123; p-&gt;next = createNode(); p = p-&gt;next; p-&gt;val = i+1; &#125; &#125; p = rec; node *head = modify(p); print(head); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.17]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-17%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int val; struct node* next;&#125; node;node* createNode()&#123; node *ret = (node*)malloc(sizeof(node)); ret-&gt;val = 0; ret-&gt;next = NULL; return ret;&#125;void print(node *head)&#123; node *p = head-&gt;next; while(p != head) &#123; printf("%d ",p-&gt;val); p = p-&gt;next; &#125; puts(""); return ;&#125;int main()&#123; int n,i,k; scanf("%d %d %d",&amp;n,&amp;i,&amp;k); node *head = createNode(); head-&gt;next = head; for(int i = n; i &gt;= 1; --i) &#123; node *p = createNode(); p-&gt;val = i; p-&gt;next = head-&gt;next; head-&gt;next = p; &#125; print(head); int cnt = 1; node *pre = head; while(cnt != i) &#123; ++cnt; pre = pre-&gt;next; &#125; node *p = pre-&gt;next; cnt = 0; while(pre != p) &#123; while(pre != p) &#123; if(p-&gt;val != 0) ++cnt; if(cnt == k) break; pre = pre-&gt;next; p = p-&gt;next; &#125; pre-&gt;next = p-&gt;next; printf("%d ",p-&gt;val); cnt = 0; free(p); p = pre-&gt;next; &#125; return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.16]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-16%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int val; struct node* next;&#125; node;//创建节点node* createNode()&#123; node *ret = (node*)malloc(sizeof(node)); ret-&gt;val = 0; ret-&gt;next = NULL; return ret;&#125;//创建s+1到n的循环链表node* createLink(int s, int n)&#123; node *head = createNode(); head-&gt;next = head; for(int i = s; i &lt; n; ++i) &#123; node *p = createNode(); p-&gt;val = n - (i-s); p-&gt;next = head-&gt;next; head-&gt;next = p; &#125; return head;&#125;//打印循环链表void print(node *head)&#123; node *p = head-&gt;next; while(p != head) &#123; printf("%d ",p-&gt;val); p = p-&gt;next; &#125; puts(""); return ;&#125;node *merge(node *x, node *y)&#123; node *ex = x; x = x-&gt;next; node *ey = y; y = y-&gt;next; node *head = createNode(); node *ph = head; while(x != ex &amp;&amp; y != ey) &#123; if(x-&gt;val &lt; y-&gt;val) &#123; ph-&gt;next = x; x = x-&gt;next; &#125; else &#123; ph-&gt;next = y; y = y-&gt;next; &#125; ph = ph-&gt;next; &#125; while(x != ex) &#123; ph-&gt;next = x; x = x-&gt;next; ph = ph-&gt;next; &#125; while(y != ey) &#123; ph-&gt;next = y; y = y-&gt;next; ph = ph-&gt;next; &#125; free(ex); free(ey); ph-&gt;next = head; return head;&#125;int main()&#123; node *x = createLink(2,13); node *y = createLink(7,9); print(x); print(y); node *head = merge(x, y); print(head);&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.15]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-15%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int val; struct node* next;&#125; node;node* createNode()&#123; node *ret = (node*)malloc(sizeof(node)); ret-&gt;val = 0; ret-&gt;next = NULL; return ret;&#125;node* createLink(int n)&#123; node *head = createNode(); for(int i = 0; i &lt; n; ++i) &#123; node *p = createNode(); p-&gt;val = rand()%100; p-&gt;next = head-&gt;next; head-&gt;next = p; &#125; return head;&#125;node* merge(node *x, node *y)&#123; node *head = createNode(); node *px = x-&gt;next; free(x); node *py = y-&gt;next; free(y); node *ph = head; while(px &amp;&amp; py) &#123; node *tx = px; px = px-&gt;next; node *ty = py; py = py-&gt;next; tx-&gt;next = ty; ty-&gt;next = NULL; ph-&gt;next = tx; ph = ty; &#125; if(px) ph-&gt;next = px; if(py) ph-&gt;next = py; return head;&#125;void print(node *p)&#123; p = p-&gt;next; while(p) &#123; printf("%d ",p-&gt;val); p = p-&gt;next; &#125; puts(""); return ;&#125;int main()&#123; srand(time(NULL)); node *x = createLink(5); print(x); node *y = createLink(6); print(y); node *head = merge(x, y); print(head); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.14]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-14%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int val; struct node* next;&#125; node;node* createNode()&#123; node *ret = (node*)malloc(sizeof(node)); ret-&gt;val = 0; ret-&gt;next = NULL; return ret;&#125;void del(node *head, int a)//删除a的前驱节点，如果a是第一个节点，则啥都不干&#123; if(head-&gt;next-&gt;val == a) return; node *pre = head; node *p = head-&gt;next; while(p-&gt;next) &#123; if(p-&gt;next-&gt;val == a) &#123; pre-&gt;next = p-&gt;next; free(p); return ; &#125; p = p-&gt;next; pre = pre-&gt;next; &#125; return ;&#125;int main()&#123; node *head = createNode(); node *tail = head; for(int i = 0; i &lt; 10; ++i) &#123; node *p = createNode(); p-&gt;val = i+1; tail-&gt;next = p; tail = tail-&gt;next; &#125; del(head, 2); node *p = head-&gt;next; while(p) &#123; printf("%d ",p-&gt;val); p = p-&gt;next; &#125; return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.13]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-13%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int val; struct node* next;&#125; node;node* createNode()&#123; node *ret = (node*)malloc(sizeof(node)); ret-&gt;val = 0; ret-&gt;next = NULL; return ret;&#125;void insert(node *head, int a, int b)//把a插入在b的前面，如果b不存在，就插在最后&#123; node *pre = head; node *p = head-&gt;next; while(p) &#123; if(p-&gt;val == b) &#123; node *q = createNode(); q-&gt;val = a; q-&gt;next = p; pre-&gt;next = q; return; &#125; pre = pre-&gt;next; p = p-&gt;next; &#125; node *q = createNode(); q-&gt;val = a; pre-&gt;next = q; return;&#125;int main()&#123; node *head = createNode(); node *tail = head; for(int i = 0; i &lt; 10; ++i) &#123; node *p = createNode(); p-&gt;val = i+1; tail-&gt;next = p; tail = tail-&gt;next; &#125; insert(head, 11, 5);//5前边插入11 insert(head, 20,33);//33前边插入20 node *p = head-&gt;next; while(p) &#123; printf("%d ",p-&gt;val); p = p-&gt;next; &#125; return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.12]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-12%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int val; struct node* next;&#125; node;node* createNode()&#123; node *ret = (node*)malloc(sizeof(node)); ret-&gt;val = 0; ret-&gt;next = NULL; return ret;&#125;void reverse(node *head)&#123; node *p = head-&gt;next; head-&gt;next = NULL; while(p) &#123; node *q = p; p = p-&gt;next; q-&gt;next = head-&gt;next; head-&gt;next = q; &#125;&#125;int main()&#123; node *head = createNode(); node *tail = head; for(int i = 0; i &lt; 10; ++i) &#123; node *p = createNode(); p-&gt;val = i+1; tail-&gt;next = p; tail = tail-&gt;next; &#125; reverse(head); node *p = head-&gt;next; while(p) &#123; printf("%d ",p-&gt;val); p = p-&gt;next; &#125; puts(""); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.11]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-11%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int val; struct node* next;&#125; node;node* createNode()&#123; node *ret = (node*)malloc(sizeof(node)); ret-&gt;val = 0; ret-&gt;next = NULL; return ret;&#125;int main()&#123; node *head = createNode(); node *tail = head; for(int i = 0; i &lt; 10; ++i) &#123; node *p = createNode(); p-&gt;val = i+1; tail-&gt;next = p; tail = tail-&gt;next; &#125; node *p = head-&gt;next; int cnt = 0; while(p) p = p-&gt;next, ++cnt; printf("%d\n",cnt); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.8]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-8%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define MAXN 100int stack[MAXN];int topl = 0;int topr = MAXN-1;void push(int n, int x)&#123; if(topr &lt; topl) &#123; puts("overflowed"); return ; &#125; if(n == 1)//左边入栈 &#123; stack[topl++] = x; &#125; else//右边入栈 &#123; stack[topr--] = x; &#125;&#125;int pop(int n)&#123; if(n == 1)//左边出栈 &#123; if(topl == 0) &#123; puts("empty"); return -1; &#125; return stack[--topl]; &#125; else//右边 &#123; if(topr == MAXN-1) &#123; puts("empty"); return -1; &#125; return stack[++topr]; &#125;&#125;int main()&#123; int n,x; while(scanf("%d",&amp;n) != EOF) &#123; if(n == 1)//表示入栈 &#123; scanf("%d %d",&amp;n,&amp;x); push(n, x); &#125; else//否则就是出栈 &#123; scanf("%d",&amp;n); printf("%d\n",pop(n)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.7]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-7%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define MAXN 100int Stack[MAXN];int top;int n;//车厢个数int que[MAXN];//存储车厢int res[MAXN];//我入栈的时候没有检测栈是否满了//出栈的时候也没有检测栈是否为空void initStack()&#123; top = 0;&#125;void Push(int x)&#123; Stack[top++] = x;&#125;int Pop()&#123; return Stack[--top];&#125;int IsEmpty()&#123; return top == 0;&#125;//1表示入栈，0表示出栈void dfs(int ptr, int lim)&#123; if(ptr == n &amp;&amp; IsEmpty()) &#123; for(int i = 0; i &lt; lim; ++i) printf("%d ",res[i]); puts(""); return ; &#125; if(ptr &lt; n)//如果车队还有车，就入栈 &#123; Push(que[ptr]); dfs(ptr+1, lim); Pop(); &#125; if(!IsEmpty())//如果栈不空，就出栈 &#123; res[lim] = Pop(); dfs(ptr, lim+1); Push(res[lim]); &#125;&#125;int main()&#123; initStack(); scanf("%d",&amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d",&amp;que[i]); dfs(0, 0);//1表示入栈操作 return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.6]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-6%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#define MAXN 100int flag[MAXN];int res[MAXN];int top = 0;int main()&#123; int n,i,k; scanf("%d %d %d",&amp;n,&amp;i,&amp;k); for(int i = 1; i &lt;= n; ++i) flag[i] = 1; int all = n; int cnt = 0; while(all) &#123; while(cnt != k) &#123; if(flag[i]) ++cnt; ++i; if(i == n+1) i = 1; &#125; cnt = 0; --all; if(i == 1) flag[n] = 0, res[top++] = n; else flag[i-1] = 0, res[top++] = i-1; &#125; for(int i = 0; i &lt; top; ++i) printf("%d ",res[i]); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.4]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-4%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546//这个程序假设x会输入成1x^1 这样可以简化处理，不然处理起来就麻烦了，宿舍太乱，不想写麻烦#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#define MAXN 100int exp[MAXN];int num[MAXN];int top = 0;char str[MAXN];//假设所有输入合法int pow(int a, int b)&#123; int ret = 1; while(b) &#123; if(b&amp;1) ret = ret*a; a = a*a; b &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; scanf("%s",str); int len = strlen(str); char *p = str; while(*p) &#123; num[top] = atoi(p); while(*p++ != '^'); exp[top++] = atoi(p); while(isdigit(*p)) p++; while(!isdigit(*p) &amp;&amp; (*p) != '\0') p++; &#125; int x0; scanf("%d",&amp;x0); int sum = 0; for(int i = 0; i &lt; top; ++i) sum += num[i]*pow(x0, exp[i]); printf("%d\n",sum); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.3]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-3%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int comp(const void *a, const void *b)&#123; return *(int*)a - *(int*)b;&#125;void print(int *a, int n)&#123; for(int i = 0; i &lt; n; ++i) printf("%d ",a[i]); puts("");&#125;int unique(int *a, int n)&#123; int ret = 1; for(int i = 1; i &lt; n; ++i) if(a[i] != a[i-1]) a[ret++] = a[i]; return ret;&#125;int main()&#123; int a[10] = &#123;1,1,3,4,4,5,4,3,1,1&#125;; print(a, 10); qsort(a,10,sizeof(a[0]),comp); print(a, 10); int n = unique(a, 10); print(a, n); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.2]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-2%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;void overturn(int *a, int n)&#123; int temp; for(int i = 0; i &lt; n/2; ++i) &#123; temp = a[i]; a[i] = a[n-i-1]; a[n-i-1] = temp; &#125;&#125;void print(int *a, int n)&#123; for(int i = 0; i &lt; n; ++i) printf("%d ",a[i]); puts("");&#125;int main()&#123; int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; print(a, 10); overturn(a, 10); print(a, 10); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蔡子经数据结构1.1]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%94%A1%E5%AD%90%E7%BB%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-1%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int sgn(int x)&#123; if(x &gt; 0) return 1; if(x &lt; 0) return -1; return 0;&#125;int cmp(int *a, int *b , int n, int m)&#123; int i = 0, j = 0; while(i &lt; n &amp;&amp; j &lt; m) &#123; if(a[i] != b[j]) return sgn(a[i]-b[j]); ++i,++j; &#125; if(i == n &amp;&amp; j == m) return 0; if(i == n) return -1; return 1;&#125;int main()&#123; int a[10] = &#123;0,1,4,7,8,5,2,3,6,9&#125;; int b[5] = &#123;0,1,4,7,8&#125;; int res = cmp(a, b, 10, 5); printf("%d\n",res); return 0;&#125;]]></content>
      <categories>
        <category>蔡子经数据结构第一章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蒟蒻的acm经历]]></title>
    <url>%2F2018%2F05%2F29%2F%E8%92%9F%E8%92%BB%E7%9A%84acm%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[虽然是个弱渣，但也想写写自己的acm经历。 初次接触编程是在初二的时候，学了段时间易语言，当时非常向往成为一名黑客，便决心大学要学计算机。就这样，高考的时候志愿填了软件工程。 大一的时候，听到学长说起过学校的acm实验室，后来也在学校的oj上看到了acm实验室纳新的信息，便报名了，当时也是害怕自己进不去实验室，就会经常刷一些基础的数据结构的题目。当时比较后悔的一件事情就是拿《算法之道》这本书作为入门书，新人表示完全看不懂。幸好后来发现了《啊哈算法》，就跟着这本书学习了基础的数据结构。在大一的时候，实验室有一个选拔，我因为一些个人的事情，没去。所以一直到大二，我才算正式进入学校的acm实验室。 参加第一个比赛是在大二，比赛是浙大陈越姥发起的那个天梯赛，比较水，学校就派了两个队，我所在的队是华东赛区团队三等奖，另一个队优秀奖。。令人比较吃惊的就是这个比赛在给学校算成绩的时候竟然是算一所学校的所有队伍的总分，这个就比较扯淡了。。。两个队的跟四个队的根本没法比，虽然我们根本可能就凑不出来四个队。。。 参加的第二场比赛是蓝桥杯的省赛，拿了个省二，伤心了几天，我的俩队友也是一一个省二，一个省三。 终于到参加acm省赛了，在青岛科技大学，当时结果是铜牌线下第一名，当时真是特别受打击，线下第一，做了三道题，按照题目难度来说，出四道题是没问题的，只是有一道题，到最后也没看懂什么意思，太坑了。我总觉得如果不是青岛科技大学把题目印错了，我队伍也不会有那么多罚时，三道题也足够拿个铜了。但是有个题印错了一个数，导致我队那题错了好多遍，罚时太多，当时真是太气了，连题目都印错了。虽说后来改正了，但是你咋不早说。 第一次省赛过后，真的是打击太大了，感觉都有点抑郁了，很压抑，当然仅仅是省赛不会造成这么大影响，还有些别的无关计算机的东西。我的两个队友，z同学是当时刚入门没多久的新手，t同学是比我早半年多进入实验室的老手，我在他俩之间。老实说，t同学确实是个话痨，爱打游戏王和王者荣耀（其实后来我也迷上了王者荣耀，好在后来戒掉了），我和t同学在实验室的机位挨着，因为比赛结果影响，我当时基本就像是在监视他，只要我在电脑前，你就别想玩游戏，感觉这样有点过分了啊。后来发现这样也没啥用，他有点话痨，他和我说话我还得回他，我偶尔也会控制不住和他说话，所以后来我就搬走了，坐在了一堆学弟中间，谁也不理我，我也不理谁。 过了几个月，大三了，也到了打争夺区域赛名额的网络赛的时候了，这时候大三一共还有三个队伍。我队伍表现最好的一次是新疆的那场网络赛，但是名次还是太低。幸运的是实验室的qianqian大佬拿到一个北京和一个青岛的名额，加上老师在青岛申请的一个名额和学长在省赛中表现好而分给的一个西安的名额，共四个区域赛名额。网络赛一共有七次，对应七个赛区，我队是综合表现最差的一队，理所当然的没有资格参加区域赛。当时是另外两个队伍重组了一个队去西安，结果打铁，不是太好。然后那两个队伍各自去青岛，拿到两块铜牌，还算可以。不过那年青岛的题也是真毒，三题从金牌卡到铜牌。。当时北京的名额出来的比较晚，而且也有点出乎大家的意料，由于每个人的参赛次数有限制，所以又要重新组一个队去北京参赛，于是老师又从三个大三的队伍中各抽一个人组队去北京，我比较幸运，我队伍里是我去参赛。北京的题比青岛要好点，三题银到铜。当时我队就做了俩签到题，挂机到结束，水到个手速铜牌，名次好像是七十多名，不得不说x姐（其实他是男的）手速还是很快的。当时有有一道区间dp的题，我也做过类似的题，但是那题多了一个条件，死活没做出来，不得不说还是太菜。 拿到这个铜牌后，真的感觉就是花光了整个大学期间所有的运气才换来这一个铜牌，因为在这两年左右的时间内，我失去的那个东西，让我太痛苦了。 很快又大三下了，还有一场acm省赛，好像是五月六号比的，也可能是七号。。。这次省赛我的队伍又有变动了，因为有一个队伍的一个同学准备考研，就退出了，我队伍的z同学便去了那个队伍，主要还是他觉得在我这个队伍没啥希望，老实说我也是这样觉得。如果有机会跳出这个队伍的话，我也会选择去别的队伍。但是毕竟t同学还没拿牌，也不能就这样丢下他啊。z同学走后，来了一个刚考完研的学长和我俩组队参加了省赛。省赛拿银，很高兴学弟拿到了金牌。老实说这次省赛锅也挺多的，据说有一个题数据没传上去，提交的程序只要不输出东西就能ac，还有一个题，标程的时间复杂度是O(n)，结果数据只能卡住O(nlogn)的程序，卡不住O(n^2)的程序，我队就被卡在这里了。别的题数据也有不少锅，总之搞的很多人都不大高兴。不过我倒是无所谓，反正不管你数据水不水，高手都是卡不住的，我们这些菜鸡互嘬，也没啥意义。 省赛之前还有一个蓝桥杯的省赛，这次拿到了省一，而且还是全省第四，虽然是b组的，不过运气还算可以。不过前两天的蓝桥国赛就被人踩爆了，拿个国二，结束后才发现我的那个暴力写的好丑啊，为什么要这样写呢？？？比较出乎意料的是蓝桥竟然出了莫比乌斯反演的题目，wtf？半年多没碰数论了，不会，暴力拿点分就行了。 记得在大二训练的时候，t同学不愿学数学，我就负责了数学，开始看组合数学的时候，看的是冯速老师翻译的那本，看的模棱两可的，感觉太难，看到后边就不再看了，就又看起来初等数论，这个还好，看起来还挺好懂，但是题也太难了，而且定理太多，记不住，看到后来，也是又不看了，还有一个原因是时间不够，就想一口吃个大胖子，但是事实证明，吃不进去啊。现在想想，当时训练的也是够乱的，菜也是活该。后来发现比赛中的数论题或者组合数学题，一般就算我学了我也做不出来，所以就不做数学了，改去做别的类型的题了，大三上在hackerrank上刷了小半年的algorithm那个面板的archive，主要就是dp，思维题，模拟，图，树之类的。感觉题也做了不少，就是独立思考的太少了。 参加acm这两年过的还是很充实的，学到了很多，也失去了很多，不过我总感觉得不偿失，还是很后悔当初付出的努力不够，大二玩王者玩的有点多，训练时还偶尔走走神，浪费了太多时间，还总是在自我安慰。退役了，安心准备考研吧。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1486[NOI2004]郁闷的出纳员]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%B4%9B%E8%B0%B7%20P1486%5BNOI2004%5D%E9%83%81%E9%97%B7%E7%9A%84%E5%87%BA%E7%BA%B3%E5%91%98%2F</url>
    <content type="text"><![CDATA[题目https://www.luogu.org/problemnew/show/P1486 题意写一个工资统计程序，实现对每个员工工资的增加和扣除，对员工的雇佣和解雇，查询工资第k多的人 题解这是第二次写这个题，第一次在这里不知道该怎么操作，想打标记也不好打，就看了题解，这次再写就会了。增加一个der变量，用来维护所有人工资的变化量，对于A操作，der+=k，对于S操作，der-=k，对于I操作，把员工工资插入splay的时候要减掉der。这样der就是所有员工工资的变化量了。然后就是普通的查询。写的时候我是把第k大的工资转换成了第k2小的工资来查询的，错了一组数据，我对比了下发现有一个查询出错了，不知道为啥，就改成了直接查询第k大的，就过了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;stdio.h&gt;const int MAXN = 2e5+10;const int INF = 1e9;struct node&#123; int ch[2]; int val,cnt,sz,ff;&#125;;node t[MAXN];int root,tot,sum,min,n;void pushUp(int x)&#123; t[x].sz = t[t[x].ch[0]].sz + t[t[x].ch[1]].sz + t[x].cnt;&#125;void Rotate(int x)&#123; int y = t[x].ff; int z = t[y].ff; int k = (t[y].ch[1] == x); t[z].ch[t[z].ch[1]==y] = x; t[x].ff = z; t[y].ch[k] = t[x].ch[k^1]; t[t[x].ch[k^1]].ff = y; t[x].ch[k^1] = y; t[y].ff = x; pushUp(y); pushUp(x);&#125;void Splay(int x, int goal)&#123; while(t[x].ff != goal) &#123; int y = t[x].ff; int z = t[y].ff; if(z != goal) (t[z].ch[0]==y)^(t[y].ch[0]==x)?Rotate(x):Rotate(y); Rotate(x); &#125; if(goal == 0) root = x;&#125;void Find(int x)&#123; int u = root; if(!u) return; while(t[u].ch[x &gt; t[u].val] &amp;&amp; x != t[u].val) u = t[u].ch[x &gt; t[u].val]; Splay(u, 0);&#125;void Insert(int x)&#123; int u = root, ff = 0; while(u &amp;&amp; t[u].val != x) &#123; ff = u; u = t[u].ch[x &gt; t[u].val]; &#125; if(u) t[u].cnt++; else &#123; u = ++tot; if(ff) t[ff].ch[x &gt; t[ff].val] = u; t[u].ch[0] = t[u].ch[1] = 0; t[u].ff = ff; t[u].val = x; t[u].cnt = t[u].sz = 1; &#125; Splay(u, 0);&#125;int Next(int x, int f)&#123; Find(x); int u = root; if(t[u].val&gt;x &amp;&amp; f) return u; if(t[u].val&lt;x &amp;&amp; !f) return u; u = t[u].ch[f]; while(t[u].ch[f^1]) u = t[u].ch[f^1]; return u;&#125;void Delete(int x)&#123; int next = Next(x, 1); Find(-INF); Splay(next, root); sum += t[t[next].ch[0]].sz; t[next].ch[0] = 0; pushUp(next); pushUp(root);&#125;int KTh(int k)&#123; int u = root; while(true) &#123; if(t[t[u].ch[1]].sz &gt;= k) u = t[u].ch[1]; else if(k &gt; t[t[u].ch[1]].sz+t[u].cnt) &#123; k -= (t[t[u].ch[1]].sz+t[u].cnt); u = t[u].ch[0]; &#125; else return t[u].val; &#125;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;min); Insert(-INF); Insert(INF); int der = 0,k; char ch; while(n--) &#123; scanf(" %c %d",&amp;ch,&amp;k); if(ch == 'I') &#123; if(k &lt; min) continue; else Insert(k-der); &#125; else if(ch == 'A') &#123; der += k; &#125; else if(ch == 'S') &#123; der -= k; Delete(min-der-1); &#125; else &#123; if(k &gt; t[root].sz-2) puts("-1"); else printf("%d\n",KTh(k+1)+der); &#125; &#125; printf("%d\n",sum); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P2286[HNOI2004]宠物收养场]]></title>
    <url>%2F2018%2F05%2F16%2F%E6%B4%9B%E8%B0%B7%20P2286%5BHNOI2004%5D%E5%AE%A0%E7%89%A9%E6%94%B6%E5%85%BB%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[题目https://www.luogu.org/problemnew/show/P2286 题意splay的基本操作 题解splay模板题可以写两个splay来写，也可以添加一个标记，用一个splay来写。我是添加了一个标记，用一个splay写的。当来了一个收养者的时候，cnt + 1，当来到一个宠物的时候，cnt - 1，cnt &gt; 0 表示收养者比宠物多， cnt &lt; 0 表示宠物比收养者多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using std::abs;struct node&#123; int ch[2]; int ff,cnt,sz,val;&#125;;const int MAXN = 1e5+10;const int MOD = 1e6;const int INF = 1000000000;int root,n,tot;node t[MAXN];void PushUp(int x)&#123; t[x].sz = t[t[x].ch[0]].sz + t[t[x].ch[1]].sz + t[x].cnt;&#125;void Rotate(int x)&#123; int y = t[x].ff; int z = t[y].ff; int k = (t[y].ch[1]==x); t[z].ch[t[z].ch[1]==y]=x; t[x].ff = z; t[y].ch[k] = t[x].ch[k^1]; t[t[x].ch[k^1]].ff = y; t[x].ch[k^1] = y; t[y].ff = x; PushUp(y); PushUp(x);&#125;void Splay(int x, int goal)&#123; while(t[x].ff != goal) &#123; int y = t[x].ff; int z = t[y].ff; if(z != goal) (t[z].ch[0]==y)^(t[y].ch[0]==x)?Rotate(x):Rotate(y); Rotate(x); &#125; if(goal == 0) root = x;&#125;void Find(int x)&#123; int u = root; if(!u) return; while(t[u].ch[x &gt; t[u].val] &amp;&amp; x != t[u].val) u = t[u].ch[x &gt; t[u].val]; Splay(u, 0);&#125;void Insert(int x)&#123; int u = root, ff = 0; while(u &amp;&amp; t[u].val != x) &#123; ff = u; t[u].sz++; u = t[u].ch[x &gt; t[u].val]; &#125; if(u) t[u].cnt++, t[u].sz++; else &#123; u = ++tot; if(ff) t[ff].ch[x &gt; t[ff].val] = u; t[u].ch[0] = t[u].ch[1] = 0; t[tot].ff = ff; t[tot].val = x; t[tot].cnt = 1; t[tot].sz = 1; &#125; Splay(u, 0);&#125;int Next(int x, int f)&#123; Find(x); int u = root; if(t[u].val &gt; x &amp;&amp; f) return u; if(t[u].val &lt; x &amp;&amp; !f) return u; u = t[u].ch[f]; while(t[u].ch[f^1]) u = t[u].ch[f^1]; return u;&#125;int FNext(int x, int f)&#123; Find(x); int u = root; if(t[u].val &gt;= x &amp;&amp; f) return u; if(t[u].val &lt;= x &amp;&amp; !f) return u; u = t[u].ch[f]; while(t[u].ch[f^1]) u = t[u].ch[f^1]; return u;&#125;void Delete(int x)&#123; int last = Next(x, 0); int next = Next(x, 1); Splay(last, 0); Splay(next, last); int del = t[next].ch[0]; if(t[del].cnt &gt; 1) &#123; t[del].cnt--; t[del].sz--; Splay(del, 0); &#125; else &#123; t[next].ch[0] = 0; PushUp(next); &#125;&#125;//a=0 表示宠物//a=1 表示领养者int main()&#123; int a,b,cnt = 0; Insert(-INF); Insert(INF); scanf("%d",&amp;n); int res = 0; while(n--) &#123; scanf("%d %d",&amp;a,&amp;b); if(cnt == 0) Insert(b); if(cnt &gt; 0) &#123; if(a == 1) Insert(b); else &#123; int fv = t[FNext(b, 0)].val; int bv = t[FNext(b, 1)].val; if(abs(fv-b) &lt;= abs(bv - b)) &#123; res += abs(fv - b); Delete(fv); &#125; else &#123; res += abs(bv - b); Delete(bv); &#125; &#125; &#125; if(cnt &lt; 0) &#123; if(a == 0) Insert(b); else &#123; int fv = t[FNext(b, 0)].val; int bv = t[FNext(b, 1)].val; if(abs(fv - b) &lt;= abs(bv - b)) &#123; res += abs(fv - b); Delete(fv); &#125; else &#123; res += abs(bv - b); Delete(bv); &#125; &#125; &#125; cnt += (a ? 1:-1); res %= MOD; &#125; printf("%d\n",res); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P3391【模板】文艺平衡树（Splay）]]></title>
    <url>%2F2018%2F05%2F14%2F%E6%B4%9B%E8%B0%B7%20P3391%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%88Splay%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目https://www.luogu.org/problemnew/show/P3391 题意写一种数据结构，实现区间翻转的操作 题解splay打个lazy标记就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123; int ch[2]; int ff,cnt,sz,val,lazy;&#125;;const int MAXN = 1e5+10;int root,n,tot,m;node t[MAXN];void PushUp(int x)&#123; t[x].sz = t[t[x].ch[0]].sz + t[t[x].ch[1]].sz + t[x].cnt;&#125;void PushDown(int x)&#123; if(t[x].lazy) &#123; t[t[x].ch[0]].lazy ^= 1; t[t[x].ch[1]].lazy ^= 1; swap(t[x].ch[0], t[x].ch[1]); t[x].lazy ^= 1; &#125;&#125;void Rotate(int x)&#123; int y = t[x].ff; int z = t[y].ff; int k = (t[y].ch[1]==x); t[z].ch[t[z].ch[1]==y]=x; t[x].ff = z; t[y].ch[k] = t[x].ch[k^1]; t[t[x].ch[k^1]].ff = y; t[x].ch[k^1] = y; t[y].ff = x; PushUp(y); PushUp(x);&#125;void Splay(int x, int goal)&#123; while(t[x].ff != goal) &#123; int y = t[x].ff; int z = t[y].ff; if(z != goal) (t[z].ch[0]==y)^(t[y].ch[0]==x)?Rotate(x):Rotate(y); Rotate(x); &#125; if(goal == 0) root = x;&#125;void Insert(int x)&#123; int u = root, ff = 0; while(u &amp;&amp; t[u].val != x) &#123; ff = u; t[u].sz++; u = t[u].ch[x &gt; t[u].val]; &#125; if(u) t[u].cnt++, t[u].sz++; else &#123; u = ++tot; if(ff) t[ff].ch[x &gt; t[ff].val] = u; t[u].ch[0] = t[u].ch[1] = 0; t[tot].ff = ff; t[tot].val = x; t[tot].sz = t[tot].cnt = 1; t[tot].lazy = 0; &#125; Splay(u, 0);&#125;int KTh(int k)&#123; int u = root; while(true) &#123; PushDown(u); if(t[t[u].ch[0]].sz + 1 &lt; k) &#123; k = k - t[t[u].ch[0]].sz - 1; u = t[u].ch[1]; &#125; else if(t[t[u].ch[0]].sz+1 &gt; k) u = t[u].ch[0]; else return u; &#125;&#125;void solve(int l, int r)&#123; l = KTh(l); r = KTh(r+2); Splay(l, 0); Splay(r, l); t[t[t[root].ch[1]].ch[0]].lazy ^= 1;&#125;void Output(int x)&#123; PushDown(x); if(t[x].ch[0]) Output(t[x].ch[0]); if(t[x].val &gt; 1 &amp;&amp; t[x].val &lt; n+2) printf("%d ",t[x].val-1); if(t[x].ch[1]) Output(t[x].ch[1]);&#125;int main()&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n+2; ++i) Insert(i); int l,r; while(m--) &#123; scanf("%d %d",&amp;l, &amp;r); solve(l, r); &#125; Output(root); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P3369【模板】普通平衡树（Treap/SBT）]]></title>
    <url>%2F2018%2F05%2F14%2F%E6%B4%9B%E8%B0%B7%20P3369%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%88Treap%20SBT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目https://www.luogu.org/problemnew/show/P3369 题意splay的基本操作 题解https://blog.csdn.net/qq_30974369/article/details/77587168 把链接中的模板拿来用就好，先插入INF和-INF作为边界，那模板功能不全，我又添加了MinTh函数和KTh函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;struct node&#123; int ch[2]; int ff,cnt,sz,val;&#125;;const int MAXN = 1e5+10;const int INF = 1e8+10;int root,n,tot;node t[MAXN];void PushUp(int x)&#123; t[x].sz = t[t[x].ch[0]].sz + t[t[x].ch[1]].sz + t[x].cnt;&#125;void Rotate(int x)&#123; int y = t[x].ff; int z = t[y].ff; int k = (t[y].ch[1]==x); t[z].ch[t[z].ch[1]==y]=x; t[x].ff = z; t[y].ch[k] = t[x].ch[k^1]; t[t[x].ch[k^1]].ff = y; t[x].ch[k^1] = y; t[y].ff = x; PushUp(y); PushUp(x);&#125;void Splay(int x, int goal)&#123; while(t[x].ff != goal) &#123; int y = t[x].ff; int z = t[y].ff; if(z != goal) (t[z].ch[0]==y)^(t[y].ch[0]==x)?Rotate(x):Rotate(y); Rotate(x); &#125; if(goal == 0) root = x;&#125;void Find(int x)&#123; int u = root; if(!u) return; while(t[u].ch[x &gt; t[u].val] &amp;&amp; x != t[u].val) u = t[u].ch[x &gt; t[u].val]; Splay(u, 0);&#125;void Insert(int x)&#123; int u = root, ff = 0; while(u &amp;&amp; t[u].val != x) &#123; ff = u; t[u].sz++; u = t[u].ch[x &gt; t[u].val]; &#125; if(u) t[u].cnt++, t[u].sz++; else &#123; u = ++tot; if(ff) t[ff].ch[x &gt; t[ff].val] = u; t[u].ch[0] = t[u].ch[1] = 0; t[tot].ff = ff; t[tot].val = x; t[tot].cnt = 1; t[tot].sz = 1; &#125; Splay(u, 0);&#125;int Next(int x, int f)&#123; Find(x); int u = root; if(t[u].val &gt; x &amp;&amp; f) return u; if(t[u].val &lt; x &amp;&amp; !f) return u; u = t[u].ch[f]; while(t[u].ch[f^1]) u = t[u].ch[f^1]; return u;&#125;void Delete(int x)&#123; int last = Next(x, 0); int next = Next(x, 1); Splay(last, 0); Splay(next, last); int del = t[next].ch[0]; if(t[del].cnt &gt; 1) &#123; t[del].cnt--; t[del].sz--; Splay(del, 0); &#125; else &#123; t[next].ch[0] = 0; PushUp(next); &#125;&#125;//查询x的最小排名void MinTh(int x)&#123; Find(x); printf("%d\n",t[t[root].ch[0]].sz);&#125;//查询排名为x的数void KTh(int x)&#123; int u = root; while(true) &#123; if(x &gt; t[t[u].ch[0]].sz &amp;&amp; x &lt;= t[t[u].ch[0]].sz+t[u].cnt) &#123; printf("%d\n",t[u].val); return; &#125; else if(x &gt; t[t[u].ch[0]].sz+t[u].cnt) &#123; x -= t[t[u].ch[0]].sz+t[u].cnt; u = t[u].ch[1]; &#125; else u = t[u].ch[0]; &#125;&#125;int main()&#123; root = tot = 0; int opt,x; scanf("%d",&amp;n); Insert(-INF); Insert(INF); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d %d",&amp;opt,&amp;x); if(opt == 1) Insert(x); else if(opt == 2) Delete(x); else if(opt == 3) MinTh(x); else if(opt == 4) KTh(x+1); else if(opt == 5) printf("%d\n",t[Next(x, 0)].val); else if(opt == 6) printf("%d\n",t[Next(x, 1)].val); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
